<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Centos7环境配置</title>
    <link href="/2024/01/17/Centos7%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"/>
    <url>/2024/01/17/Centos7%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/</url>
    
    <content type="html"><![CDATA[<h2 id="Centos-基础环境初始化"><a href="#Centos-基础环境初始化" class="headerlink" title="Centos 基础环境初始化"></a>Centos 基础环境初始化</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">更新阿里云yum源</span><br>wget -0 /etc/yum.repos.d/CentOS-Base.repo http://mirrors.aliyun,com/repo/Centos-7.repo  #基础仓库<br>wget -0 /etc/yum.repos.d/epel.repo http://mirrors.aliyun.com/repo/epel-7.repo #额外的仓库<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">清空yum本地缓存</span><br>yum clean all<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">生成yum新的缓存</span><br>yum makecache<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">清空现有规则</span><br>iptables -F<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">确保是<span class="hljs-built_in">disable</span>的状态</span><br>getenforce <br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">常用功能组件 可装可不装</span><br>yum install -y bash-completion vim lrzsz wget expect net-tools nc nmap dos2unix htop iftop iotop unzip telnet sl psmic nethogs glances bc nptdate openldap-dev<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">禁止开机自启防火墙</span><br>systemctl disable firewalld<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">停止防火墙服务</span><br>systemctl stop firewalld <br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">查看linux内核版本</span><br>uname -r<br><br></code></pre></td></tr></table></figure><h2 id=""><a href="#" class="headerlink" title=""></a></h2>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Docker基础命令</title>
    <link href="/2023/07/19/Docker%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4/"/>
    <url>/2023/07/19/Docker%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4/</url>
    
    <content type="html"><![CDATA[<h1 id="Docker-基本操作"><a href="#Docker-基本操作" class="headerlink" title="Docker 基本操作"></a>Docker 基本操作</h1><h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><ul><li><code>sndo systemctl start docker</code> 启动docker</li><li><code>sudo systemctl status docker</code> 查看docker状态</li><li><code>sudo systemctl restart docker</code> 重启docker</li><li><code>sudo systemctl stop docker</code> 停止docker</li><li><code>docker version</code> 查看docker的版本号</li><li><code>docker pull 应用镜像名:版本号</code> 在镜像仓库下载镜像</li><li><code>docker images</code> 查出当前docker所有镜像（包含下载镜像与自己创建的镜像）</li><li><code>docker rmi 镜像tag/id</code> 删除镜像 这里面还有说法。。。 docker rmi -f 强制删除、</li></ul><p>批量删除镜像的两种方式</p><ol><li><p>使用$() 表达式进行删除</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker rmi -f $(docker images -qa)<br></code></pre></td></tr></table></figure></li><li><p>使用xargs</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker images -q | xargs docker rmi -f<br></code></pre></td></tr></table></figure></li></ol><ul><li><code>docker save -o 导出的tar文件名 仓库:标签名</code> 导出镜像</li><li><code>docker load -i xx.tar</code> 导入镜像</li><li><code>docker image prune</code> 清理镜像</li></ul><h2 id="容器命令"><a href="#容器命令" class="headerlink" title="容器命令"></a>容器命令</h2><ul><li><p><code>docker ps</code>  列出正在运行的Docker容器</p></li><li><p><code>docker run 镜像tag</code> 启动镜像创建容器，在docker中容器的启动方式有两种 一种是：交互式启动 一种是：后台启动</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker run -it -p 8090:80 --name my-nginx nginx /bin/bash<br>参数解释：<br>-i ：在容器中指定一个终端。<br>-t：允许我们对容器的终端进行输出或输出<br>– name 为启动的容器设置名称<br>-p ：port（宿主机）+port（容器内）<br>bin/bash指定终端交互的shell解释器<br><br>docker run -d -p 8090:80 --name my-nginx nginx <br>参数解释：<br>-d 后台运行<br>-p ：port（宿主机）+port（容器内）<br>– name 为启动的容器设置名称<br>最后一个nginx代表的nginx:latest 镜像，默认latest可以进行省略。<br></code></pre></td></tr></table></figure></li><li><p><code>docker exec -it 容器id/容器名称  /bin/bash</code>  进入一个正在运行的容器</p><p>进入容器后退出容器 有两种方式 1 直接输入 exit 退出容器并停止容器 2 快捷键 ctrl + p +q 退出容器但不停止容器运行</p></li><li><p><code>docker start 容器名称或容器ID</code> 启动一个已停止的容器</p></li><li><p><code>docker stop 容器名称或容器ID</code> 停止容器</p></li><li><p><code>docker restart 容器名称或容器ID</code> 重新启动一个已停止的容器</p></li><li><p><code>docker rm -f 容器名称或容器id</code> 删除容器，其中-f为强制删除</p></li><li><p>导出容器</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">方式一： docker <span class="hljs-built_in">export</span> -o xx.tar 容器名称或容器<span class="hljs-built_in">id</span><br>方式二：docker <span class="hljs-built_in">export</span> 容器名称或容器<span class="hljs-built_in">id</span> &gt; xx.tar<br></code></pre></td></tr></table></figure></li><li><p>导入容器</p><figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs elm"><span class="hljs-title">docker</span> <span class="hljs-keyword">import</span> xx.tar REPOSITORY:TAG<br></code></pre></td></tr></table></figure></li><li><p><code>docker top 容器id或容器名称</code>  查看容器进程</p></li><li><p><code>docker stats 容器id或容器名称</code> 查看容器内CPU、内存、存储或网络信息</p></li><li><p><code>docker inspect 容器id或容器名称</code> 查看容器详情</p></li><li><p><code>docker cp 容器id或容器名:容器中文件路径 主机路径</code>   复制容器文件到主机</p></li><li><p><code>docker cp 主机文件路径 容器id或容器名:容器中文件路径</code>  拷贝主机的文件到容器中</p></li><li><p><code>docker diff 容器id或容器名称</code> diff 看容器内文件系统的变更 类似与操作日志</p></li><li><p><code>docker port 容器id或容器名称</code>  <strong>查看容器占用端口信息</strong></p></li><li><p><code>docker logs --tail 10 容器id或容器名称</code>  查看容器最后十条日志记录</p></li><li><p><code>docker build -t 镜像名称:tag .</code>   将当前目录作为（软件包）构建上下文，并根据dockerfile构建生成一个镜像文件</p></li></ul><p>要在Docker中运行前端项目，可以按照以下步骤进行操作：</p><ol><li>创建 Dockerfile：在项目的根目录中创建一个名为 Dockerfile 的文件，该文件用于定义 Docker 镜像的构建方式。可以使用文本编辑器打开 Dockerfile 文件，并将以下内容复制粘贴进去：</li></ol><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs Dockerfile"><span class="hljs-comment"># 指定基础镜像</span><br><span class="hljs-keyword">FROM</span> nginx:latest<br><br><span class="hljs-comment"># 将本地的 HTML、CSS 和 JavaScript 文件复制到容器中的指定目录</span><br><span class="hljs-keyword">COPY</span><span class="language-bash"> . /usr/share/nginx/html</span><br><br><span class="hljs-comment"># 指定容器对外暴露的端口号</span><br><span class="hljs-keyword">EXPOSE</span> <span class="hljs-number">80</span><br><br><span class="hljs-comment"># 容器启动时运行的命令</span><br><span class="hljs-keyword">CMD</span><span class="language-bash"> [<span class="hljs-string">&quot;nginx&quot;</span>, <span class="hljs-string">&quot;-g&quot;</span>, <span class="hljs-string">&quot;daemon off;&quot;</span>]</span><br></code></pre></td></tr></table></figure><p>上述 Dockerfile 使用 nginx 作为基础镜像，并将当前目录中的文件复制到容器中的 <code>/usr/share/nginx/html</code> 目录下。它还暴露了容器的 80 端口，并且通过 nginx 命令启动容器。</p><ol><li>构建 Docker 镜像：打开终端或命令行界面，进入到 Dockerfile 所在的目录，并执行以下命令来构建 Docker 镜像：</li></ol><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs erlang">docker build -t your_image_name .<br></code></pre></td></tr></table></figure><p>将 <code>your_image_name</code> 替换为你自己的镜像名称。注意，最后的命令中有一个点，表示使用当前目录作为构建上下文。</p><ol><li>运行 Docker 容器：构建完成后，可以使用以下命令运行 Docker 容器：</li></ol><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">docker</span> run -d -p <span class="hljs-number">8080</span>:<span class="hljs-number">80</span> your_image_name<br></code></pre></td></tr></table></figure><p>这将在容器内部的 80 端口上运行 nginx，并将容器的 80 端口映射到主机的 8080 端口。你可以根据需要修改端口映射。</p><ol><li>访问前端应用：在浏览器中访问 <code>http://localhost:8080</code>，即可查看运行在 Docker 容器中的前端应用。</li></ol><p>这样，你应该能够使用 Docker 运行你的前端项目。注意，上述步骤假设你的前端项目是一个静态网页应用。如果你的前端项目具有其他依赖项，如服务端接口或数据库，你可能需要在 Dockerfile 中添加更多配置来支持这些依赖项。</p><h2 id="安装Docker"><a href="#安装Docker" class="headerlink" title="安装Docker"></a>安装Docker</h2><p>开启linux内核的流量转发</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs shell">cat &lt;&lt;EOF &gt; /etc/sysctl.d/docker.conf<br>net.bridge.bridge-nf-call-ip6tables = 1<br>net.bridge.bridge-nf-call-iptables = 1<br>net.ipv4.conf.default.rp_filter = 0<br>net.ipv4.conf.all.rp_filter = 0<br>net.ipv4.ip_forward=1<br>EOF <br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">加载修改内核的参数 配置文件</span><br>sysctl -p /etc/sysctl.d/docker.conf<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">如果报错文件找不到 就先执行这条指令</span><br>modprobe br_netfilter<br></code></pre></td></tr></table></figure><p>利用yum快速安装docker</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">查看yum源中可用的docker版本</span> <br>yum list docker-ce --showduplicates | sort -r<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">提前配置好yum仓库</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">1.阿里云自带仓库 2.阿里云提供的docker专属repo仓库</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">利用curl 命令下载仓库文件</span><br>curl -o /etc/yum.repos.d/Centos-7.repo http://mirros.aliyun.com/repo/Centos-7.repo<br>curl -o /etc/yum.repos.d/docker-ce/repo http://mirros.aliyun.com/docker-ce/linux/centos/docker-ce.repo<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">更新yum缓存</span><br>yum clean all &amp;&amp; yum makecache<br></code></pre></td></tr></table></figure><p>配置docker镜像加速器 用于加速镜像文件的下载</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">创建deamon.json 文件</span><br>vim /etc/docker/deamon.json<br><span class="hljs-meta prompt_"># </span><span class="language-bash">写入一下内容</span><br>&#123;<br>&quot;registry-mirrors”: [&quot;https://8xpk5wnt .mirror.aliyuncs.com&quot;]<br>&#125;<br><span class="hljs-meta prompt_"># </span><span class="language-bash">重新读取deamon 配置文件</span><br>systemctl deamon-reload<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">设置docker开机自启动</span><br>systemctl enable docker<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">启动docker</span><br>system restart docker<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">验证是否启动</span><br>ps -ef|grep docker<br>[root@DESKTOP-9ES0CIB /]# ps -ef|grep docker<br>root       155     1  0 20:56 ?        00:00:01 /usr/bin/dockerd -H fd:// --containerd=/run/containerd/containerd.sock<br>root       761   344  0 22:21 pts/0    00:00:00 grep --color=auto docker<br><br>[root@DESKTOP-9ES0CIB /]# docker version<br>Client: Docker Engine - Community<br> Version:           24.0.4<br> API version:       1.43<br> Go version:        go1.20.5<br> Git commit:        3713ee1<br> Built:             Fri Jul  7 14:54:21 2023<br> OS/Arch:           linux/amd64<br> Context:           default<br><br>Server: Docker Engine - Community<br> Engine:<br>  Version:          24.0.4<br>  API version:      1.43 (minimum version 1.12)<br>  Go version:       go1.20.5<br>  Git commit:       4ffc614<br>  Built:            Fri Jul  7 14:53:26 2023<br>  OS/Arch:          linux/amd64<br>  Experimental:     false<br> containerd:<br>  Version:          1.6.21<br>  GitCommit:        3dce8eb055cbb6872793272b4f20ed16117344f8<br> runc:<br>  Version:          1.1.7<br>  GitCommit:        v1.1.7-0-g860f061<br> docker-init:<br>  Version:          0.19.0<br>  GitCommit:        de40ad0<br><br></code></pre></td></tr></table></figure><p>Nginx web服务器 运行出一个80端口的网站</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">在宿主机linux上 运行nginx</span><br>1 开启服务器<br>2 在服务器上安装好运行nginx所需的依赖关系<br>3 安装nginx  yum install nginx -y<br>4 修改nginx的配置文件<br>5 启动nginx<br>6 客户端去访问nginx<br></code></pre></td></tr></table></figure><h2 id="Docker容器管理"><a href="#Docker容器管理" class="headerlink" title="Docker容器管理"></a>Docker容器管理</h2><p><code>docker run</code> 等于创建+启动</p><blockquote><p>docker run 镜像名 如果镜像本地不存在，则会在线去下载该镜像</p></blockquote><p><strong>注意：容器内的进程必须处于前台运行状态，否则容器就会直接退出</strong></p><p>自己部署容器运行的时候，命令不得后台运行，前台运行即可</p><p>如果容器内什么事儿也没有做，那么容器也会挂掉，容器内必须有一个进程在前台运行</p><p>像运行nginx的基础镜像，没有运行任何程序因此容器直接挂掉</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">运行容器的玩法</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">1 运行一个挂掉的容器（错误示范）</span><br>docker run centos:7.8.2003<br>这个写法会产生多条独立的容器记录，且容器内没有程序再跑，因此直接挂掉，留下记录<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">2 运行容器，且进入容器内，且在容器内执行某个命令</span><br>docker run -it centos:7.8.2003 sh<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">3 开启一个容器，让他帮你运行某个程序，属于前台运行，会卡住一个终端</span><br>docker run centos:7.8.2003 ping www.baidu.com<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">4 运行一个活着的容器，可以通过docker ps 看得到</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">-d 参数 让容器在后台跑着返回容器的<span class="hljs-built_in">id</span> （针对宿主机而言）</span><br>docker run -d centos:7.8.2003 ping www.baidu.com<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">5 丰富docker容器运行的参数</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">-d 后台运行</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">--<span class="hljs-built_in">rm</span> 容器挂掉后自动删除容器记录</span> <br><span class="hljs-meta prompt_"># </span><span class="language-bash">--name 给运行的容器起名</span><br>docker run -d --rm --name messiah centos:7.8.2003 ping www.baidu.com<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">6 查看容器日志，并刷新日志</span><br>docker logs 容器id<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">7 进入正在运行的容器空间内</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">-it 交互式操作</span><br>docker exec -it 容器id bash<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">8 查看容器的详细信息，用于高级的调试</span><br>docker container inspect 容器id<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">9 容器的端口映射</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">-p 宿主机端口:容器端口</span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">后台运行一个nginx容器 并起个名字，端口映射配置将宿主机的80端口映射到容器内的80端口</span><br>docker run -d --name messiah_nginx -p 80:80 nginx<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">9.1 查看容器的端口映射转发情况</span><br>docker port 容器id<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">9.2 随机端口映射</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">-P 随机访问宿主机的一个空闲端口，映射到容器内打开的端口</span><br>docker run -d -P nginx<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">10 容器的提交</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">10.1 运行基础的centos7 在容器内安装vim 然后提交新的镜像</span><br>docker run -it centos7 bash<br>yum install vim -y<br>docker commit 容器id 新的镜像名 <br><span class="hljs-meta prompt_"># </span><span class="language-bash">10.2 运行新的镜像，就可以直接使用vim</span><br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>NPM与PNPM</title>
    <link href="/2023/04/18/NPM%E4%B8%8EPNPM/"/>
    <url>/2023/04/18/NPM%E4%B8%8EPNPM/</url>
    
    <content type="html"><![CDATA[<h1 id="NPM与PNPM"><a href="#NPM与PNPM" class="headerlink" title="NPM与PNPM"></a>NPM与PNPM</h1><h2 id="NPM简介"><a href="#NPM简介" class="headerlink" title="NPM简介"></a>NPM简介</h2><h3 id="NPM是个干嘛的？"><a href="#NPM是个干嘛的？" class="headerlink" title="NPM是个干嘛的？"></a>NPM是个干嘛的？</h3><p>​npm是node.js的包管理工具，用来解决Node.js代码部署问题。在安装Node.js时会自动安装相应的npm版本,不需要单独安装。使用npm包管理工具可以解决如下场景的需求。</p><ol><li>从npm服务器下载别人编写的第三方包到本地使用。</li><li>从npm服务器下载并安装别人编写的命令程序到本地使用。</li><li>将自己编写的包或命令行程序上传到npm服务器供别人使用。</li></ol><h3 id="NPM常用命令介绍"><a href="#NPM常用命令介绍" class="headerlink" title="NPM常用命令介绍"></a>NPM常用命令介绍</h3><p>​npm提供了快速操作包的命令，只需要简单命令就可以很方便地对第三方包进行管理，下面列举了npm中的常用命令。</p><ul><li>npm install:安装项目所需要的全部包，需要配置 package.json文件。</li><li>npm uninstall:卸载指定名称的包。</li><li>npm install包名:安装指定名称的包，后面可以跟参数“-g”表示全局安装“–save表示本地安装。注意不带参数默认本地安装。</li><li>npm update:更新指定名称的包。</li><li>npm start:项目启动;通过CDN方式引入 Vue，可以缓解服务器的压力，加快文件的下载速度。目前，网络上有很多免费的CDN服务器可以使用。</li><li>npm run build:项目构建。</li></ul><p>由于npm的服务器在国外，使用npm下载软件包的速度非常慢，为了提高下载速度，推荐读者切换成国内的镜像服务器来使用。以淘宝NPM镜像为例,使用如下命令设置即可切换。</p><p>由于npm的服务器在国外，使用npm下载软件包的速度非常慢，为了提高下载速度，推荐读者切换成国内的镜像服务器来使用。以淘宝NPM镜像为例,使用如下命令设置即可切换。</p><p>由于npm的服务器在国外，使用npm下载软件包的速度非常慢，为了提高下载速度，推荐读者切换成国内的镜像服务器来使用。以淘宝NPM镜像为例,使用如下命令设置即可切换。</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arduino">npm config set registry https:<span class="hljs-comment">//registry.npm.taobao.org</span><br></code></pre></td></tr></table></figure><p>当然也可以直接使用淘宝的npm镜像源，淘宝 NPM 镜像是一个完整 npmjs.org 镜像，你可以用此代替官方版本(只读)，同步频率目前为 10分钟 一次以保证尽量与官方服务同步。</p><p>你可以使用淘宝定制的 cnpm (gzip 压缩支持) 命令行工具代替默认的 npm:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">npm install -g cnpm --registry=<span class="hljs-attr">https</span>:<span class="hljs-comment">//registry.npmmirror.com</span><br></code></pre></td></tr></table></figure><h2 id="PNPM简介"><a href="#PNPM简介" class="headerlink" title="PNPM简介"></a>PNPM简介</h2><h3 id="PNPM概念"><a href="#PNPM概念" class="headerlink" title="PNPM概念"></a>PNPM概念</h3><p>​performant npm ，意味“高性能的 npm”。<a href="https://so.csdn.net/so/search?q=pnpm&spm=1001.2101.3001.7020">pnpm</a>由npm&#x2F;yarn衍生而来，解决了npm&#x2F;yarn内部潜在的bug，极大的优化了性能，扩展了使用场景。被誉为“最先进的包管理工具”</p><h3 id="PNPM特点"><a href="#PNPM特点" class="headerlink" title="PNPM特点"></a>PNPM特点</h3><p>​速度快、节约磁盘空间、支持monorepo、安全性高</p><p>​pnpm 相比较于 yarn&#x2F;npm 这两个常用的包管理工具在性能上也有了极大的提升，根据目前官方提供的 <a href="https://so.csdn.net/so/search?q=benchmark&spm=1001.2101.3001.7020">benchmark</a> 数据可以看出在一些综合场景下比 npm&#x2F;yarn 快了大概两倍。</p><h3 id="存储管理"><a href="#存储管理" class="headerlink" title="存储管理"></a>存储管理</h3><p>​按内容寻址、采用symlink</p><h3 id="依赖管理"><a href="#依赖管理" class="headerlink" title="依赖管理"></a>依赖管理</h3><p>​npm1、npm2采用递归管理，npm3、npm3+、yarn依赖扁平化管理消除依赖提升。</p><p>​pnpm依赖策略：消除依赖提升、规范拓扑结构</p><h3 id="安全"><a href="#安全" class="headerlink" title="安全"></a>安全</h3><p>​之前在使用 npm&#x2F;yarn 的时候，由于 node_module 的扁平结构，如果 A 依赖 B， B 依赖 C，那么 A 当中是可以直接使用 C 的，但问题是 A 当中并没有声明 C 这个依赖。因此会出现这种非法访问的情况。 但 pnpm 自创了一套依赖管理方式，很好地解决了这个问题，保证了安全性。</p><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>​在我们使用<code>npm i pnpm -g</code>全局安装pnpm后，在vscode中使用pnpm相关的命令时打开可能会出现错误</p><p><img src="/images/image-20230418225820418.png"></p><p>​解决办法 以管理员身份运行Windos PowerShell，运行 <code>set-ExecutionPolicy RemoteSigned</code> 指令，并且输入 Y ，即可</p><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ol><li><a href="http://hz.itheima.com/news/20211012/175847.html">npm是什么意思？npm常用命令介绍 (itheima.com)</a></li><li><a href="https://blog.csdn.net/weixin_60409964/article/details/129525662">(123条消息) 安装 pnpm 出现 : 无法加载文件 D:\node\node_global\pnpm.ps1，因为在此系统上禁止运行脚本。有关详细信息，请参阅 https:&#x2F;go.microsoft. 解决办法_前端_奇点的博客-CSDN博客</a></li><li><a href="https://blog.csdn.net/snowball_li/article/details/124787870">(123条消息) pnpm：简介_snow@li的博客-CSDN博客</a></li><li><a href="https://www.jianshu.com/p/6c695a0692e0">JavaScript常见面试题：npm跟pnpm有什么区别？ - 简书 (jianshu.com)</a></li></ol>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>正则表达式基础</title>
    <link href="/2023/04/17/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%9F%BA%E7%A1%80/"/>
    <url>/2023/04/17/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<h1 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h1><h2 id="基本符号"><a href="#基本符号" class="headerlink" title="基本符号"></a>基本符号</h2><ul><li><code>[]</code>:字符组，允许匹配一组可能出现的字符。需要注意的是在这里中括号只能代表一个字符。</li><li><code>-</code>：连字符，代表区间。</li><li><code>\</code>：转义字符，对特殊字符（一般指的是正则中具有含义的字符，例如：<code>-</code>、<code>^</code>）进行匹配的时候需要用到转义字符。</li><li><code>^</code>：取反字符，一般用于字符组中来表示取反或者不包含，注意如果用在开头的话，表示匹配已什么开头。</li><li><code>$</code>：指定的是一个字符串的结束，表示匹配以什么结尾。</li><li><code>.</code>：字符代表匹配任何单个字符，它<strong>只能出现在方括号以外</strong>。<strong>值得注意的是：</strong> <code>.</code>字符只有一个不能匹配的字符，也就是换行符（<code>\n</code>），不过要让<code>.</code>字符与换 行符匹配也是可以的，以后会讨论。</li><li><code>?</code>：指定一个字符、字符组或其他基本单元可选，这意味着正则表达式引擎将会期望该字符出现<strong>零次或一次</strong>。</li><li><code>&#123;N&#125;</code>：重复，在一个字符后加上<code>&#123;N&#125;</code>,就可以表示在它之前的字符出现N次。</li><li><code>&#123;M,N&#125;</code>：重复区间，m是最少出现次数，n为最大出现次数。<code>\d&#123;3,4&#125;</code> 既可以匹配<code>3</code>个数字也可以匹配<code>4</code>个数字，不过当有<code>4</code>个数字的时候，优先匹配的是<code>4</code>个数字，这是因为正则表达式默认是<strong>贪婪模式</strong>，即尽可能的匹配更多字符，而要使用<strong>非贪婪模式</strong>，我们要在<strong>表达式后面加上 <code>?</code>号</strong>。</li><li><code>&#123;M,&#125;</code>：开闭区间，表示匹配M个或者无数个。</li><li><code>*</code>：匹配0次或多次，开闭区间的速写字符指定常见重复情况，<code>*</code>等价于<code>&#123;0,&#125;</code></li><li><code>+</code>：匹配1次或多次，开闭区间的速写字符指定常见重复情况，<code>+</code>等价于<code>&#123;1,&#125;</code></li></ul><h2 id="特殊符号组合"><a href="#特殊符号组合" class="headerlink" title="特殊符号组合"></a>特殊符号组合</h2><ul><li><code>\w</code>：与任意单词字符匹配，任意单词字符表示 <code>[A-Z]</code>、 <code>[a-z]</code>、<code>[0-9]</code>、<code>_</code>,匹配包括下划线的任何单词字符。等价于<code>[A-Za-z0-9_]</code>。</li><li><code>\W</code>：匹配任何非单词字符。等价于<code>[^A-Za-z0-9_]</code></li><li><code>\d</code>：与任意数字匹配。匹配一个数字字符。等价于 <code>[0-9]</code>。</li><li><code>\D</code>：匹配一个非数字字符。等价于 <code>[^0-9]</code></li><li><code>\s</code>：快捷方式可以<strong>匹配空白字符</strong>，比如空格，tab、换行等。匹配任何空白字符，包括空格、制表符、换页符等等。等价于 <code>[ \f\n\r\t\v]</code>。</li><li><code>\S</code>：匹配任何非空白字符。等价于 <code>[^ \f\n\r\t\]</code>。</li><li><code>\b</code> ：匹配的是单词的边界</li></ul><h2 id="预查符号"><a href="#预查符号" class="headerlink" title="预查符号"></a>预查符号</h2><ul><li><code>(?=pattern)</code>：正向否定预查(negative assert)，在任何不匹配pattern的字符串开始处匹配查找字符串。这是一个非获取匹配，也就是说，该匹配不需要获取供以后使用。例如”Windows(?!95|98|NT|2000)”能匹配”Windows3.1”中的”Windows”，但不能匹配”Windows2000”中的”Windows”。预查不消耗字符，也就是说，在一个匹配发生后，在最后一次匹配之后立即开始下一次匹配的搜索，而不是从包含预查的字符之后开始。**<code>xxx(?=pattern)</code>匹配符合pattern之前出现的数据**</li><li><code>(?!pattern)</code>：正向否定预查(negative assert)，在任何不匹配pattern的字符串开始处匹配查找字符串。这是一个非获取匹配，也就是说，该匹配不需要获取供以后使用。例如”Windows(?!95|98|NT|2000)”能匹配”Windows3.1”中的”Windows”，但不能匹配”Windows2000”中的”Windows”。预查不消耗字符，也就是说，在一个匹配发生后，在最后一次匹配之后立即开始下一次匹配的搜索，而不是从包含预查的字符之后开始。**<code>xxx(?!pattern)</code>不匹配pattern之前出现的数据**</li><li><code>(?&lt;=pattern)</code>：反向(look behind)肯定预查，与正向肯定预查类似，只是方向相反。例如，”<code>(?&lt;=95|98|NT|2000)Windows</code>“能匹配”<code>2000Windows</code>“中的”<code>Windows</code>“，但不能匹配”<code>3.1Windows</code>“中的”<code>Windows</code>“。**<code>(?&lt;=pattern)xxxx</code>匹配符合pattern之后出现的数据**</li><li><code>(?&lt;!pattern)</code>：反向否定预查，与正向否定预查类似，只是方向相反。例如”<code>(?&lt;!95|98|NT|2000)Windows</code>“能匹配”<code>3.1Windows</code>“中的”<code>Windows</code>“，但不能匹配”<code>2000Windows</code>“中的”<code>Windows</code>“。**<code>(?&lt;!pattern)xxx</code>不匹配符合pattern之后出现的数据**</li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Springboot整合websocket基础版</title>
    <link href="/2023/02/07/Springboot%E6%95%B4%E5%90%88websocket%E5%9F%BA%E7%A1%80%E7%89%88/"/>
    <url>/2023/02/07/Springboot%E6%95%B4%E5%90%88websocket%E5%9F%BA%E7%A1%80%E7%89%88/</url>
    
    <content type="html"><![CDATA[<h1 id="Springboot整合websocket基础版"><a href="#Springboot整合websocket基础版" class="headerlink" title="Springboot整合websocket基础版"></a>Springboot整合websocket基础版</h1><h2 id="WebSocket的介绍"><a href="#WebSocket的介绍" class="headerlink" title="WebSocket的介绍"></a>WebSocket的介绍</h2><p>​websocket是一种在单个tcp连接上进行全双工通信的协议，我们传统的http通信协议由客户端发起与服务端进行三次握手建立链接，四次挥手断开连接，这样就会存在一种情况 我们的服务端无法主动将我们的数据发送给我们的客户端，也就是说只能单方面的进行通信，而websocket的出现正是为了解决这一现象，</p><h2 id="客户端实现"><a href="#客户端实现" class="headerlink" title="客户端实现"></a>客户端实现</h2><p>客户端API：<a href="https://developer.mozilla.org/en-US/docs/Web/API/WebSocket/WebSocket">https://developer.mozilla.org/en-US/docs/Web/API/WebSocket/WebSocket</a></p><p>vue参考样例</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 初始化websocket连接</span><br><span class="hljs-comment">     */</span><br><span class="hljs-title function_">wsInit</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-comment">//定义后端websocket连接地址</span><br>    <span class="hljs-comment">// var socketUrl = &quot;ws://192.168.9.63:8001/kingoetl/websocket/connection.do&quot;;</span><br>    <span class="hljs-keyword">var</span> socketUrl =<br>        (process.<span class="hljs-property">env</span>.<span class="hljs-property">NODE_ENV</span> === <span class="hljs-string">&quot;development&quot;</span><br>         ? <span class="hljs-string">&quot;ws://192.168.9.63:8001&quot;</span><br>         : <span class="hljs-string">&quot;ws://&quot;</span> + process.<span class="hljs-property">env</span>.<span class="hljs-property">VUE_APP_WS_IP</span>) +<br>        <span class="hljs-string">&quot;/kingoetl/websocket/connection.do&quot;</span>;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">ws</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">WebSocket</span>(socketUrl);<br>    <span class="hljs-comment">// 连接打开事件</span><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">ws</span>.<span class="hljs-property">onopen</span> = <span class="hljs-function">() =&gt;</span> &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;WebSocket 已打开&quot;</span>);<br>    &#125;;<br>    <span class="hljs-comment">//收到消息事件</span><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">ws</span>.<span class="hljs-property">onmessage</span> = <span class="hljs-function"><span class="hljs-params">msg</span> =&gt;</span> &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(msg.<span class="hljs-property">data</span>, msg);<br>        <span class="hljs-keyword">const</span> obj = <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">parse</span>(msg.<span class="hljs-property">data</span>);<br>        <span class="hljs-comment">//收到消息调用我们的方法</span><br>        <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">onServerMessage</span>(obj);<br>    &#125;;<br>&#125;,<br></code></pre></td></tr></table></figure><h2 id="服务端实现"><a href="#服务端实现" class="headerlink" title="服务端实现"></a>服务端实现</h2><h3 id="引入websocket相关依赖"><a href="#引入websocket相关依赖" class="headerlink" title="引入websocket相关依赖"></a>引入websocket相关依赖</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">&lt;dependency&gt;<br>    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;<br>    &lt;artifactId&gt;spring-boot-starter-websocket&lt;/artifactId&gt;<br>&lt;/dependency&gt;<br></code></pre></td></tr></table></figure><h3 id="websocket核心配置类（入口）"><a href="#websocket核心配置类（入口）" class="headerlink" title="websocket核心配置类（入口）"></a>websocket核心配置类（入口）</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.kingosoft.web.config;<br><br><br><span class="hljs-keyword">import</span> com.kingosoft.web.filter.WebsocketHandshakeInterceptor;<br><span class="hljs-keyword">import</span> com.kingosoft.web.handler.WebsocketHandler;<br><span class="hljs-keyword">import</span> org.springframework.context.annotation.Bean;<br><span class="hljs-keyword">import</span> org.springframework.context.annotation.Configuration;<br><span class="hljs-keyword">import</span> org.springframework.web.socket.config.annotation.EnableWebSocket;<br><span class="hljs-keyword">import</span> org.springframework.web.socket.config.annotation.WebSocketConfigurer;<br><span class="hljs-keyword">import</span> org.springframework.web.socket.config.annotation.WebSocketHandlerRegistry;<br><br><br><br><span class="hljs-meta">@Configuration</span><br><span class="hljs-meta">@EnableWebSocket</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">WebSocketConfig</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">WebSocketConfigurer</span> &#123;<br>    <span class="hljs-comment">//实现WebSocketConfigurer接口，重写registerWebSocketHandlers方法，这是一个核心实现方法，配置websocket入口，允许访问的域、注册Handler、SockJs支持和拦截器。</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">registerWebSocketHandlers</span><span class="hljs-params">(WebSocketHandlerRegistry webSocketHandlerRegistry)</span> &#123;<br>        webSocketHandlerRegistry<br>            .addHandler(myController(), <span class="hljs-string">&quot;/websocket/connection.do&quot;</span>)<span class="hljs-comment">//注册和路由的功能，当客户端发起websocket连接，把/path交给对应的handler处理，而不实现具体的业务逻辑，可以理解为收集和任务分发中心。</span><br>            .setAllowedOrigins(<span class="hljs-string">&quot;*&quot;</span>)<span class="hljs-comment">//允许指定的域名或IP(含端口号)建立长连接，如果只允许自家域名访问，这里轻松设置。如果不限时使用&quot;*&quot;号，如果指定了域名，则必须要以http或https开头。</span><br>            .addInterceptors(myHandshakeInterceptor());<span class="hljs-comment">//顾名思义就是为handler添加拦截器，可以在调用handler前后加入我们自己的逻辑代码。</span><br>        <span class="hljs-comment">//不支持websocket的，采用sockjs</span><br>        <span class="hljs-comment">//        webSocketHandlerRegistry</span><br>        <span class="hljs-comment">//                .addHandler(myController(), &quot;/sockjs/connection&quot;)</span><br>        <span class="hljs-comment">//                .setAllowedOrigins(&quot;*&quot;)</span><br>        <span class="hljs-comment">//                .addInterceptors(myHandshakeInterceptor())</span><br>        <span class="hljs-comment">//                .withSockJS();</span><br>    &#125;<br><br>    <span class="hljs-comment">//    @Bean</span><br>    <span class="hljs-comment">//    public ServletServerContainerFactoryBean createWebSocketContainer() &#123;</span><br>    <span class="hljs-comment">//        ServletServerContainerFactoryBean container = new ServletServerContainerFactoryBean();</span><br>    <span class="hljs-comment">//        container.setMaxTextMessageBufferSize(8 * 1024);</span><br>    <span class="hljs-comment">//        container.setMaxBinaryMessageBufferSize(8 * 1024);</span><br>    <span class="hljs-comment">//        return container;</span><br>    <span class="hljs-comment">//    &#125;</span><br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * For Tomcat, WildFly, and GlassFish add a ServletServerContainerFactoryBean</span><br><span class="hljs-comment">     * to your WebSocket Java config:</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-comment">//    @Bean</span><br>    <span class="hljs-comment">//    public ServletServerContainerFactoryBean createWebSocketContainer() &#123;</span><br>    <span class="hljs-comment">//        ServletServerContainerFactoryBean container = new ServletServerContainerFactoryBean();</span><br>    <span class="hljs-comment">//        container.setMaxTextMessageBufferSize(4096);</span><br>    <span class="hljs-comment">//        container.setMaxBinaryMessageBufferSize(4096);</span><br>    <span class="hljs-comment">//        return container;</span><br>    <span class="hljs-comment">//    &#125;</span><br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * For Jetty, you’ll need to supply a pre-configured Jetty WebSocketServerFactory</span><br><span class="hljs-comment">     * and plug that into Spring’s DefaultHandshakeHandler through your WebSocket Java config:</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-comment">//    @Bean</span><br>    <span class="hljs-comment">//    public DefaultHandshakeHandler handshakeHandler() &#123;</span><br>    <span class="hljs-comment">//</span><br>    <span class="hljs-comment">//        WebSocketPolicy policy = new WebSocketPolicy(WebSocketBehavior.SERVER);</span><br>    <span class="hljs-comment">//        policy.setInputBufferSize(8192); /* 设置消息缓冲大小 */</span><br>    <span class="hljs-comment">//        policy.setIdleTimeout(600000); /* 10分钟read不到数据的话，则断开该客户端 */</span><br>    <span class="hljs-comment">//</span><br>    <span class="hljs-comment">//        return new DefaultHandshakeHandler(</span><br>    <span class="hljs-comment">//                new JettyRequestUpgradeStrategy(policy));</span><br>    <span class="hljs-comment">//    &#125;</span><br><br><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> WebsocketHandler <span class="hljs-title function_">myController</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">WebsocketHandler</span>();<br>    &#125;<br><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> WebsocketHandshakeInterceptor <span class="hljs-title function_">myHandshakeInterceptor</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">WebsocketHandshakeInterceptor</span>();<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="websocket拦截器"><a href="#websocket拦截器" class="headerlink" title="websocket拦截器"></a>websocket拦截器</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.kingosoft.web.filter;<br><br><span class="hljs-keyword">import</span> org.springframework.http.server.ServerHttpRequest;<br><span class="hljs-keyword">import</span> org.springframework.http.server.ServerHttpResponse;<br><span class="hljs-keyword">import</span> org.springframework.http.server.ServletServerHttpRequest;<br><span class="hljs-keyword">import</span> org.springframework.web.socket.WebSocketHandler;<br><span class="hljs-keyword">import</span> org.springframework.web.socket.server.HandshakeInterceptor;<br><br><span class="hljs-keyword">import</span> javax.servlet.http.HttpSession;<br><span class="hljs-keyword">import</span> java.util.Map;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@PackageName</span>: com.kingosoft.web.filter</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@ClassName</span>: WebsocketHandshakeInterceptor</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Description</span>: Todo</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Author</span>: wangcong</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Date</span>: 22-4-26 10:06</span><br><span class="hljs-comment"> **/</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">WebsocketHandshakeInterceptor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">HandshakeInterceptor</span> &#123;<br>    <span class="hljs-comment">//握手前</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">beforeHandshake</span><span class="hljs-params">(ServerHttpRequest serverHttpRequest, ServerHttpResponse serverHttpResponse, WebSocketHandler webSocketHandler, Map&lt;String, Object&gt; map)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-comment">//        if (serverHttpRequest instanceof ServletServerHttpRequest) &#123;</span><br>        <span class="hljs-comment">//            ServletServerHttpRequest servletRequest = (ServletServerHttpRequest) serverHttpRequest;</span><br>        <span class="hljs-comment">//            HttpSession session = servletRequest.getServletRequest().getSession(false);</span><br>        <span class="hljs-comment">//            //如果用户已经登录，允许聊天</span><br>        <span class="hljs-comment">//            if(session.getAttribute(&quot;loginUser&quot;)!=null)&#123;</span><br>        <span class="hljs-comment">//</span><br>        <span class="hljs-comment">//                //将用户放入socket处理器的会话(WebSocketSession)中</span><br>        <span class="hljs-comment">//                map.put(&quot;loginUser&quot;, loginUser);</span><br>        <span class="hljs-comment">//                System.out.println(&quot;Websocket:用户[ID:&quot; + (loginUser.getId() + &quot;,Name:&quot;+loginUser.getNickname()+&quot;]要建立连接&quot;));</span><br>        <span class="hljs-comment">//            &#125;else&#123;</span><br>        <span class="hljs-comment">//                //用户没有登录，拒绝聊天</span><br>        <span class="hljs-comment">//                //握手失败！</span><br>        <span class="hljs-comment">//                System.out.println(&quot;--------------握手已失败...&quot;);</span><br>        <span class="hljs-comment">//                return false;</span><br>        <span class="hljs-comment">//            &#125;</span><br>        <span class="hljs-comment">//        &#125;</span><br>        System.out.println(<span class="hljs-string">&quot;--------------握手开始...&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br><br>    <span class="hljs-comment">//握手后</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">afterHandshake</span><span class="hljs-params">(ServerHttpRequest serverHttpRequest, ServerHttpResponse serverHttpResponse, WebSocketHandler webSocketHandler, Exception e)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;--------------握手成功啦...&quot;</span>);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="webSocketHandler"><a href="#webSocketHandler" class="headerlink" title="webSocketHandler"></a>webSocketHandler</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.kingosoft.web.handler;<br><br><span class="hljs-keyword">import</span> com.alibaba.fastjson.JSON;<br><span class="hljs-keyword">import</span> org.springframework.stereotype.Service;<br><span class="hljs-keyword">import</span> org.springframework.web.socket.PongMessage;<br><span class="hljs-keyword">import</span> org.springframework.web.socket.TextMessage;<br><span class="hljs-keyword">import</span> org.springframework.web.socket.WebSocketSession;<br><span class="hljs-keyword">import</span> org.springframework.web.socket.handler.TextWebSocketHandler;<br><br><span class="hljs-keyword">import</span> java.io.IOException;<br><span class="hljs-keyword">import</span> java.util.HashMap;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@PackageName</span>: com.kingosoft.web.handler</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@ClassName</span>: WebsocketHandler</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Description</span>: Todo</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Author</span>: wangcong</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Date</span>: 22-4-26 10:03</span><br><span class="hljs-comment"> **/</span><br><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">WebsocketHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">TextWebSocketHandler</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> WebSocketSession webSocketSession= <span class="hljs-literal">null</span>;<br><br>    <span class="hljs-comment">//在我们的连接建立后会自动调用我们的这个方法</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">afterConnectionEstablished</span><span class="hljs-params">(WebSocketSession session)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-built_in">super</span>.afterConnectionEstablished(session);<br>        System.out.println(<span class="hljs-string">&quot;websocket连接建立成功&quot;</span>);<br>        webSocketSession = session;<br>        System.out.println(session);<br>    &#125;<br><br>    <span class="hljs-comment">//调用此方法给客户端发送消息</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sendMessage</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-type">TextMessage</span> <span class="hljs-variable">textMessage1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TextMessage</span>(<span class="hljs-string">&quot;1&quot;</span>);<br>        <span class="hljs-keyword">try</span> &#123;<br>            webSocketSession.sendMessage(textMessage1);<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sendMessage</span><span class="hljs-params">(HashMap map)</span>&#123;<br>        <span class="hljs-comment">// 在找到更好的办法之前先用JSON串进行传输</span><br>        <span class="hljs-type">TextMessage</span> <span class="hljs-variable">textMessage1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TextMessage</span>(JSON.toJSONString(map));<br>        <span class="hljs-keyword">try</span> &#123;<br>            webSocketSession.sendMessage(textMessage1);<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br><br><br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p>四种服务端的websocket实现方式：<a href="https://zhuanlan.zhihu.com/p/531474864">https://zhuanlan.zhihu.com/p/531474864</a><br>Spring WebSocket详解：<a href="https://www.cnblogs.com/nosqlcoco/p/5860730.html">https://www.cnblogs.com/nosqlcoco/p/5860730.html</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>FreeMarker基础</title>
    <link href="/2023/01/30/FreeMarker%E5%9F%BA%E7%A1%80/"/>
    <url>/2023/01/30/FreeMarker%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<h1 id="Freemaker基础"><a href="#Freemaker基础" class="headerlink" title="Freemaker基础"></a>Freemaker基础</h1><p>官方文档：<a href="http://www.kerneler.com/freemarker2.3.23/toc.html">http://www.kerneler.com/freemarker2.3.23/toc.html</a></p><p>FreeMarker 是一款 <em>模板引擎</em>： 即一种基于模板和要改变的数据， 并用来生成输出文本(HTML网页，电子邮件，配置文件，源代码等)的通用工具。 它不是面向最终用户的，而是一个Java类库，是一款程序员可以嵌入他们所开发产品的组件。</p><p>模板编写为FreeMarker Template Language (FTL)，生成类型为ftl结尾后缀的文件，需要注意的是fll语言是区分大小写的，特别在指令的使用时。</p><h2 id="模板怎么写"><a href="#模板怎么写" class="headerlink" title="模板怎么写"></a>模板怎么写</h2><p>首先模板文件存放在Web服务器上，就像通常存放静态HTML页面那样。当有人来访问这个页面， FreeMarker将会介入执行，然后动态转换模板，用最新的数据内容替换模板中 <code>$&#123;...&#125;</code> 的部分， 之后将结果发送到访问者的Web浏览器中。这整个过程就是 将 模板+数据模型 &#x3D; 输出。</p><p> 在模板中使用<code>$&#123;xxx&#125;</code>来获取数据模型中的标量值。</p><p>显而易见数据模型就是我们为模板而准备的，也就是说需要在模板中所使用的到的数据。一般数据模型给人的感觉就是一种树形的目录结构，存储具体的单值的变量我们称之为<strong>scalars</strong> （标量），而标量一般都只存在于子变量中，多个子变量构成集合，在这里被称为序列，和集合一样在序列中的子变量没有名字，只是列表中的项。</p><p>标量类型可以分为如下的类别：</p><ul><li>字符串：就是文本，也就是任意的字符序列，比如上面提到的 ‘’m’’, ‘’o’’, ‘’u’’, ‘’s’’, ‘’e’’。比如 <code>name</code> 和 <code>size</code> 也是字符串。</li><li>数字：这是数值类型，就像上面的 <code>price</code>。 在FreeMarker中，字符串 <code>&quot;50&quot;</code> 和数字 <code>50</code> 是两种完全不同的东西。前者是两个字符的序列 (这恰好是人们可以读的一个数字)，而后者则是可以在数学运算中直接被使用的数值。</li><li>日期&#x2F;时间: 可以是日期-时间格式(存储某一天的日期和时间)， 或者是日期(只有日期，没有时间)，或者是时间(只有时间，没有日期)。</li><li>布尔值：对应着对&#x2F;错(是&#x2F;否，开&#x2F;关等值)类似的值。 比如动物可以有一个 <code>protected</code> (受保护的，译者注) 的子变量， 该变量存储这个动物是否被保护起来的值。</li></ul><p>总结：</p><ul><li>数据模型可以被看成是树形结构。</li><li>标量用于存储单一的值。这种类型的值可以是字符串，数字，日期&#x2F;时间或者是布尔值。</li><li>哈希表是一种存储变量及其相关且有唯一标识名称的容器。</li><li>序列是存储有序变量的容器。存储的变量可以通过数字索引来检索，索引通常从0开始。</li></ul><h2 id="总体结构"><a href="#总体结构" class="headerlink" title="总体结构"></a>总体结构</h2><p>实际上用程序语言编写的程序就是模板。 <strong>FTL</strong> (代表FreeMarker模板语言)。 这是为编写模板设计的非常简单的编程语言。</p><p>模板(FTL编程)是由如下部分混合而成的：</p><ul><li><strong>文本</strong>：文本会照着原样来输出。</li><li><strong>插值</strong>：这部分的输出会被计算的值来替换。插值由 <code>$&#123;</code> and <code>&#125;</code> 所分隔(或者 <code>#&#123;</code> and <code>&#125;</code>，这种风格已经不建议再使用了；<a href="http://www.kerneler.com/freemarker2.3.23/ref_depr_numerical_interpolation.html">点击查看更多</a>)。</li><li><strong>FTL 标签</strong>：FTL标签和HTML标签很相似，但是它们却是给FreeMarker的指示， 而且不会打印在输出内容中。</li><li><strong>注释</strong>：注释和HTML的注释也很相似，但它们是由 <code>&lt;#--</code> 和 <code>--&gt;</code>来分隔的。注释会被FreeMarker直接忽略， 更不会在输出内容中显示。</li></ul><p>请注意非常重要的几点：<br>插值 仅仅可以在 文本 中使用。 (也可以是字符串表达式；请参考 <a href="http://www.kerneler.com/freemarker2.3.23/dgui_template_exp.html#dgui_template_exp_stringop_interpolation">后续内容</a>)<br>FTL 标签 不可以在其他 FTL 标签 和 插值中使用。比如， 这样做是 <em>错误</em> 的： <code>&lt;#if &lt;#include &#39;foo&#39;&gt;=&#39;bar&#39;&gt;...&lt;/#if&gt;</code><br>注释 可以放在 FTL 标签 和 插值中。</p><h3 id="FTL标签"><a href="#FTL标签" class="headerlink" title="FTL标签"></a>FTL标签</h3><p>……</p><p>在我们项目中的实际应用</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Oracle用户角色权限基本操作</title>
    <link href="/2022/12/05/Oracle%E7%94%A8%E6%88%B7%E8%A7%92%E8%89%B2%E6%9D%83%E9%99%90%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/"/>
    <url>/2022/12/05/Oracle%E7%94%A8%E6%88%B7%E8%A7%92%E8%89%B2%E6%9D%83%E9%99%90%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/</url>
    
    <content type="html"><![CDATA[<p>一、创建用户并赋予权限</p><p>1、创建用户</p><p>create user messiah identified by 123456;</p><p>2、赋权</p><p>grant dba to messiah;</p><p>grant create session to messiah; –会话权限（没有该权限无法登录，也可以直接将OBA角色给予）</p><p>3、查看已经赋予用户的系统权限</p><p>select * from user_sys_privs;</p><p>二、创建角色</p><p>角色，即权限的集合，可以把一个角色授予给用户</p><p>1、创建角色</p><p>create role myrole;</p><p>2、赋权</p><p>grant create session to myrole;–将创建session的权限授予给角色myrole</p><p>3、赋角色给用户</p><p>grant myrole to zhangsan;–授予zhangsan用户myrole的角色</p><p>4、删除角色</p><p>drop role myrole;</p><p>查看所有用户</p><p>select * from dba_users;</p><p>select * from all_users;</p><p>select * from user_users;</p><p>alter user user_name account lock; 锁住用户</p><p>alter user user_name account unlock; 解锁用户</p><p>查询当前用户所拥有的权限</p><p>select * from session_privs;</p><p>查看用户被赋予的系统权限(直接赋值给用户或角色的系统权限)</p><p>select * from dba_sys_privs where grantee &#x3D; ‘RESOURCE’;</p><p>select * from user_sys_privs;</p><p>注：USER_SYS_PRIVS 视图列出已经授予用户的系统权限。</p><p>它的列包括Username、Privilege和 Admin_Option(设置为YES 或NO 的一个标志，用来指出是否用with admin option 授予权限)，直接授予用户的所有系统权限都可以通过该视图显示，通过角色授予用户的系统权限不能在此视图中显示。</p><p>查看所有角色</p><p>select * from dba_roles;</p><p>查看用户所拥有的角色</p><p>select * from session_roles order by role;–返回当前用户被授予的全部角色, 包括嵌套授权的角色</p><p>select * from dba_role_privs;</p><p>select * from user_role_privs;</p><p>查看当前用户角色所包含的权限</p><p>select * from role_sys_privs where role &#x3D; ‘CONNECT’;</p><p>查看用户对象权限</p><p>select * from dba_tab_privs;</p><p>select * from all_tab_privs;</p><p>select * from user_tab_privs;</p><p>查看哪些用户有sysdba或sysoper系统权限(查询时需要相应权限)</p><p>select * from v$pwfile_users;</p><p>查看用户与默认表空间的关系</p><p>select username, default_tablespace from dba_users where username&#x3D;’SCOTT’;</p><p>查看当前用户的表</p><p>select * from user_tables;</p><p>可视化赋权：</p><p>1、使用ins用户建表</p><p>2、使用mobapp用户（管理员）将ins用户的某个表赋权给odso用户</p><p>users——&gt;ins，选中要赋权的表赋权（右键，编辑，权限）</p><p>等同于：grant select, insert, update, delete on ins.tb_cablecheck_equ_odso to odso;</p><p>3、使用odso用户登录，增删改查该表测试</p><p>命令赋权：</p><p>赋予权限：grant … to …</p><p>撤销权限：revoke … from …</p><p>登陆</p><p>grant create session to zhangsan;</p><p>使用表空间</p><p>grant unlimited tablespace to zhangsan;</p><p>创建表</p><p>grant create table to zhangsan;</p><p>删除表</p><p>grant drop table to zhangsan;</p><p>grant drop on table_name to user_name;</p><p>插入表</p><p>grant insert table to zhangsan;</p><p>grant insert on table_name to user_name;</p><p>grant insert(id) on table_name to user_name;</p><p>更新表数据</p><p>grant update table to zhangsan;</p><p>grant update on table_name to user_name;</p><p>grant update(id) on table_name to user_name;</p><p>修改表结构</p><p>grant alter table on table_name to user_name;</p><p>查询表</p><p>grant select on table_name to user_name;</p><p>创建过程</p><p>grant create any procedure to username;</p><p>执行过程</p><p>grant execute any procedure to username;</p><p>grant execute on ins.p_trun_link_odso to odso_insert；</p><p>授予所有权限(all)给所有用户(public)</p><p>grant all to public;</p><p>权限传递</p><p>即用户A将权限授予B，B可以将操作的权限再授予C，</p><p>命令如下：</p><p>grant alter table on table_name to user_name with admin option;</p><p>grant update on table_name to user_name with grant option; –转移更新权限</p><p>grant alter table on table_name to user_name with grant option;</p><h2 id="oracle命令行重新启动"><a href="#oracle命令行重新启动" class="headerlink" title="oracle命令行重新启动"></a>oracle命令行重新启动</h2><ol><li>sqlplus&#x2F;nolog</li><li>conn sys &#x2F; as sysdba</li><li>shutdown immediate</li><li>startup</li></ol>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>VUE3快速上手</title>
    <link href="/2022/08/29/VUE3%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B/"/>
    <url>/2022/08/29/VUE3%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="Vue3快速上手"><a href="#Vue3快速上手" class="headerlink" title="Vue3快速上手"></a>Vue3快速上手</h1><img src="https://user-images.githubusercontent.com/499550/93624428-53932780-f9ae-11ea-8d16-af949e16a09f.png" style="width:200px" /><h2 id="1-Vue3简介"><a href="#1-Vue3简介" class="headerlink" title="1.Vue3简介"></a>1.Vue3简介</h2><ul><li>2020年9月18日，Vue.js发布3.0版本，代号：One Piece（海贼王）</li><li>耗时2年多、<a href="https://github.com/vuejs/vue-next/graphs/commit-activity">2600+次提交</a>、<a href="https://github.com/vuejs/rfcs/tree/master/active-rfcs">30+个RFC</a>、<a href="https://github.com/vuejs/vue-next/pulls?q=is:pr+is:merged+-author:app/dependabot-preview+">600+次PR</a>、<a href="https://github.com/vuejs/vue-next/graphs/contributors">99位贡献者</a> </li><li>github上的tags地址：<a href="https://github.com/vuejs/vue-next/releases/tag/v3.0.0">https://github.com/vuejs/vue-next/releases/tag/v3.0.0</a></li></ul><h2 id="2-Vue3带来了什么"><a href="#2-Vue3带来了什么" class="headerlink" title="2.Vue3带来了什么"></a>2.Vue3带来了什么</h2><h3 id="1-性能的提升"><a href="#1-性能的提升" class="headerlink" title="1.性能的提升"></a>1.性能的提升</h3><ul><li><p>打包大小减少41%</p></li><li><p>初次渲染快55%, 更新渲染快133%</p></li><li><p>内存减少54%</p><p>……</p></li></ul><h3 id="2-源码的升级"><a href="#2-源码的升级" class="headerlink" title="2.源码的升级"></a>2.源码的升级</h3><ul><li><p>使用Proxy代替defineProperty实现响应式</p></li><li><p>重写虚拟DOM的实现和Tree-Shaking</p><p>……</p></li></ul><h3 id="3-拥抱TypeScript"><a href="#3-拥抱TypeScript" class="headerlink" title="3.拥抱TypeScript"></a>3.拥抱TypeScript</h3><ul><li>Vue3可以更好的支持TypeScript</li></ul><h3 id="4-新的特性"><a href="#4-新的特性" class="headerlink" title="4.新的特性"></a>4.新的特性</h3><ol><li><p>Composition API（组合API）</p><ul><li>setup配置</li><li>ref与reactive</li><li>watch与watchEffect</li><li>provide与inject</li><li>……</li></ul></li><li><p>新的内置组件</p><ul><li>Fragment </li><li>Teleport</li><li>Suspense</li></ul></li><li><p>其他改变</p><ul><li>新的生命周期钩子</li><li>data 选项应始终被声明为一个函数</li><li>移除keyCode支持作为 v-on 的修饰符</li><li>……</li></ul></li></ol><h1 id="一、创建Vue3-0工程"><a href="#一、创建Vue3-0工程" class="headerlink" title="一、创建Vue3.0工程"></a>一、创建Vue3.0工程</h1><h2 id="1-使用-vue-cli-创建"><a href="#1-使用-vue-cli-创建" class="headerlink" title="1.使用 vue-cli 创建"></a>1.使用 vue-cli 创建</h2><p>官方文档：<a href="https://cli.vuejs.org/zh/guide/creating-a-project.html#vue-create">https://cli.vuejs.org/zh/guide/creating-a-project.html#vue-create</a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">## 查看@vue/cli版本，确保@vue/cli版本在4.5.0以上</span><br>vue --version<br><span class="hljs-comment">## 安装或者升级你的@vue/cli</span><br>npm install -g @vue/cli<br><span class="hljs-comment">## 创建</span><br>vue create vue_test<br><span class="hljs-comment">## 启动</span><br><span class="hljs-built_in">cd</span> vue_test<br>npm run serve<br></code></pre></td></tr></table></figure><h2 id="2-使用-vite-创建"><a href="#2-使用-vite-创建" class="headerlink" title="2.使用 vite 创建"></a>2.使用 vite 创建</h2><p>官方文档：<a href="https://v3.cn.vuejs.org/guide/installation.html#vite">https://v3.cn.vuejs.org/guide/installation.html#vite</a></p><p>vite官网：<a href="https://vitejs.cn/">https://vitejs.cn</a></p><ul><li>什么是vite？—— 新一代前端构建工具。</li><li>优势如下：<ul><li>开发环境中，无需打包操作，可快速的冷启动。</li><li>轻量快速的热重载（HMR）。</li><li>真正的按需编译，不再等待整个应用编译完成。</li></ul></li><li>传统构建 与 vite构建对比图</li></ul><p><img src="https://cn.vitejs.dev/assets/bundler.37740380.png" style="width:500px;height:280px;float:left" /><img src="https://cn.vitejs.dev/assets/esm.3070012d.png" style="width:480px;height:280px" /></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">## 创建工程</span><br>npm init vite-app &lt;project-name&gt;<br><span class="hljs-comment">## 进入工程目录</span><br><span class="hljs-built_in">cd</span> &lt;project-name&gt;<br><span class="hljs-comment">## 安装依赖</span><br>npm install<br><span class="hljs-comment">## 运行</span><br>npm run dev<br></code></pre></td></tr></table></figure><h1 id="二、常用-Composition-API"><a href="#二、常用-Composition-API" class="headerlink" title="二、常用 Composition API"></a>二、常用 Composition API</h1><p>官方文档: <a href="https://v3.cn.vuejs.org/guide/composition-api-introduction.html">https://v3.cn.vuejs.org/guide/composition-api-introduction.html</a></p><h2 id="1-拉开序幕的setup"><a href="#1-拉开序幕的setup" class="headerlink" title="1.拉开序幕的setup"></a>1.拉开序幕的setup</h2><ol><li>理解：Vue3.0中一个新的配置项，值为一个函数。</li><li>setup是所有<strong style="color:#DD5145">Composition API（组合API）</strong><i style="color:gray;font-weight:bold">“ 表演的舞台 ”</i>。</li><li>组件中所用到的：数据、方法等等，均要配置在setup中。</li><li>setup函数的两种返回值：<ol><li>若返回一个对象，则对象中的属性、方法, 在模板中均可以直接使用。（重点关注！）</li><li><span style="color:#aad">若返回一个渲染函数：则可以自定义渲染内容。（了解）</span></li></ol></li><li>注意点：<ol><li>尽量不要与Vue2.x配置混用<ul><li>Vue2.x配置（data、methos、computed…）中<strong style="color:#DD5145">可以访问到</strong>setup中的属性、方法。</li><li>但在setup中<strong style="color:#DD5145">不能访问到</strong>Vue2.x配置（data、methos、computed…）。</li><li>如果有重名, setup优先。</li></ul></li><li>setup不能是一个async函数，因为返回值不再是return的对象, 而是promise, 模板看不到return对象中的属性。（后期也可以返回一个Promise实例，但需要Suspense和异步组件的配合）</li></ol></li></ol><h2 id="2-ref函数"><a href="#2-ref函数" class="headerlink" title="2.ref函数"></a>2.ref函数</h2><ul><li>作用: 定义一个响应式的数据</li><li>语法: <code>const xxx = ref(initValue)</code> <ul><li>创建一个包含响应式数据的<strong style="color:#DD5145">引用对象（reference对象，简称ref对象）</strong>。</li><li>JS中操作数据： <code>xxx.value</code></li><li>模板中读取数据: 不需要.value，直接：<code>&lt;div&gt;&#123;&#123;xxx&#125;&#125;&lt;/div&gt;</code></li></ul></li><li>备注：<ul><li>接收的数据可以是：基本类型、也可以是对象类型。</li><li>基本类型的数据：响应式依然是靠<code>Object.defineProperty()</code>的<code>get</code>与<code>set</code>完成的。</li><li>对象类型的数据：内部 <i style="color:gray;font-weight:bold">“ 求助 ”</i> 了Vue3.0中的一个新函数—— <code>reactive</code>函数。</li></ul></li></ul><h2 id="3-reactive函数"><a href="#3-reactive函数" class="headerlink" title="3.reactive函数"></a>3.reactive函数</h2><ul><li>作用: 定义一个<strong style="color:#DD5145">对象类型</strong>的响应式数据（基本类型不要用它，要用<code>ref</code>函数）</li><li>语法：<code>const 代理对象= reactive(源对象)</code>接收一个对象（或数组），返回一个<strong style="color:#DD5145">代理对象（Proxy的实例对象，简称proxy对象）</strong></li><li>reactive定义的响应式数据是“深层次的”。</li><li>内部基于 ES6 的 Proxy 实现，通过代理对象操作源对象内部数据进行操作。</li></ul><h2 id="4-Vue3-0中的响应式原理"><a href="#4-Vue3-0中的响应式原理" class="headerlink" title="4.Vue3.0中的响应式原理"></a>4.Vue3.0中的响应式原理</h2><h3 id="vue2-x的响应式"><a href="#vue2-x的响应式" class="headerlink" title="vue2.x的响应式"></a>vue2.x的响应式</h3><ul><li><p>实现原理：</p><ul><li><p>对象类型：通过<code>Object.defineProperty()</code>对属性的读取、修改进行拦截（数据劫持）。</p></li><li><p>数组类型：通过重写更新数组的一系列方法来实现拦截。（对数组的变更方法进行了包裹）。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">defineProperty</span>(data, <span class="hljs-string">&#x27;count&#x27;</span>, &#123;<br>    get () &#123;&#125;, <br>    set () &#123;&#125;<br>&#125;)<br></code></pre></td></tr></table></figure></li></ul></li><li><p>存在问题：</p><ul><li>新增属性、删除属性, 界面不会更新。</li><li>直接通过下标修改数组, 界面不会自动更新。</li></ul></li></ul><h3 id="Vue3-0的响应式"><a href="#Vue3-0的响应式" class="headerlink" title="Vue3.0的响应式"></a>Vue3.0的响应式</h3><ul><li><p>实现原理: </p><ul><li><p>通过Proxy（代理）:  拦截对象中任意属性的变化, 包括：属性值的读写、属性的添加、属性的删除等。</p></li><li><p>通过Reflect（反射）:  对源对象的属性进行操作。</p></li><li><p>MDN文档中描述的Proxy与Reflect：</p><ul><li><p>Proxy：<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Proxy">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Proxy</a></p></li><li><p>Reflect：<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Reflect">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Reflect</a></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">new</span> <span class="hljs-title class_">Proxy</span>(data, &#123;<br><span class="hljs-comment">// 拦截读取属性值</span><br>    get (target, prop) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">get</span>(target, prop)<br>    &#125;,<br>    <span class="hljs-comment">// 拦截设置属性值或添加新属性</span><br>    set (target, prop, value) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">set</span>(target, prop, value)<br>    &#125;,<br>    <span class="hljs-comment">// 拦截删除属性</span><br>    deleteProperty (target, prop) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">deleteProperty</span>(target, prop)<br>    &#125;<br>&#125;)<br><br>proxy.<span class="hljs-property">name</span> = <span class="hljs-string">&#x27;tom&#x27;</span>   <br></code></pre></td></tr></table></figure></li></ul></li></ul></li></ul><h2 id="5-reactive对比ref"><a href="#5-reactive对比ref" class="headerlink" title="5.reactive对比ref"></a>5.reactive对比ref</h2><ul><li>从定义数据角度对比：<ul><li>ref用来定义：<strong style="color:#DD5145">基本类型数据</strong>。</li><li>reactive用来定义：<strong style="color:#DD5145">对象（或数组）类型数据</strong>。</li><li>备注：ref也可以用来定义<strong style="color:#DD5145">对象（或数组）类型数据</strong>, 它内部会自动通过<code>reactive</code>转为<strong style="color:#DD5145">代理对象</strong>。</li></ul></li><li>从原理角度对比：<ul><li>ref通过<code>Object.defineProperty()</code>的<code>get</code>与<code>set</code>来实现响应式（数据劫持）。</li><li>reactive通过使用<strong style="color:#DD5145">Proxy</strong>来实现响应式（数据劫持）, 并通过<strong style="color:#DD5145">Reflect</strong>操作<strong style="color:orange">源对象</strong>内部的数据。</li></ul></li><li>从使用角度对比：<ul><li>ref定义的数据：操作数据<strong style="color:#DD5145">需要</strong><code>.value</code>，读取数据时模板中直接读取<strong style="color:#DD5145">不需要</strong><code>.value</code>。</li><li>reactive定义的数据：操作数据与读取数据：<strong style="color:#DD5145">均不需要</strong><code>.value</code>。</li></ul></li></ul><h2 id="6-setup的两个注意点"><a href="#6-setup的两个注意点" class="headerlink" title="6.setup的两个注意点"></a>6.setup的两个注意点</h2><ul><li><p>setup执行的时机</p><ul><li>在beforeCreate之前执行一次，this是undefined。</li></ul></li><li><p>setup的参数</p><ul><li>props：值为对象，包含：组件外部传递过来，且组件内部声明接收了的属性。</li><li>context：上下文对象<ul><li>attrs: 值为对象，包含：组件外部传递过来，但没有在props配置中声明的属性, 相当于 <code>this.$attrs</code>。</li><li>slots: 收到的插槽内容, 相当于 <code>this.$slots</code>。</li><li>emit: 分发自定义事件的函数, 相当于 <code>this.$emit</code>。</li></ul></li></ul></li></ul><h2 id="7-计算属性与监视"><a href="#7-计算属性与监视" class="headerlink" title="7.计算属性与监视"></a>7.计算属性与监视</h2><h3 id="1-computed函数"><a href="#1-computed函数" class="headerlink" title="1.computed函数"></a>1.computed函数</h3><ul><li><p>与Vue2.x中computed配置功能一致</p></li><li><p>写法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123;computed&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span><br><br><span class="hljs-title function_">setup</span>(<span class="hljs-params"></span>)&#123;<br>    ...<br><span class="hljs-comment">//计算属性——简写</span><br>    <span class="hljs-keyword">let</span> fullName = <span class="hljs-title function_">computed</span>(<span class="hljs-function">()=&gt;</span>&#123;<br>        <span class="hljs-keyword">return</span> person.<span class="hljs-property">firstName</span> + <span class="hljs-string">&#x27;-&#x27;</span> + person.<span class="hljs-property">lastName</span><br>    &#125;)<br>    <span class="hljs-comment">//计算属性——完整</span><br>    <span class="hljs-keyword">let</span> fullName = <span class="hljs-title function_">computed</span>(&#123;<br>        <span class="hljs-title function_">get</span>(<span class="hljs-params"></span>)&#123;<br>            <span class="hljs-keyword">return</span> person.<span class="hljs-property">firstName</span> + <span class="hljs-string">&#x27;-&#x27;</span> + person.<span class="hljs-property">lastName</span><br>        &#125;,<br>        <span class="hljs-title function_">set</span>(<span class="hljs-params">value</span>)&#123;<br>            <span class="hljs-keyword">const</span> nameArr = value.<span class="hljs-title function_">split</span>(<span class="hljs-string">&#x27;-&#x27;</span>)<br>            person.<span class="hljs-property">firstName</span> = nameArr[<span class="hljs-number">0</span>]<br>            person.<span class="hljs-property">lastName</span> = nameArr[<span class="hljs-number">1</span>]<br>        &#125;<br>    &#125;)<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h3 id="2-watch函数"><a href="#2-watch函数" class="headerlink" title="2.watch函数"></a>2.watch函数</h3><ul><li><p>与Vue2.x中watch配置功能一致</p></li><li><p>两个小“坑”：</p><ul><li>监视reactive定义的响应式数据时：oldValue无法正确获取、强制开启了深度监视（deep配置失效）。</li><li>监视reactive定义的响应式数据中某个属性时：deep配置有效。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//情况一：监视ref定义的响应式数据</span><br><span class="hljs-title function_">watch</span>(sum,<span class="hljs-function">(<span class="hljs-params">newValue,oldValue</span>)=&gt;</span>&#123;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;sum变化了&#x27;</span>,newValue,oldValue)<br>&#125;,&#123;<span class="hljs-attr">immediate</span>:<span class="hljs-literal">true</span>&#125;)<br><br><span class="hljs-comment">//情况二：监视多个ref定义的响应式数据</span><br><span class="hljs-title function_">watch</span>([sum,msg],<span class="hljs-function">(<span class="hljs-params">newValue,oldValue</span>)=&gt;</span>&#123;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;sum或msg变化了&#x27;</span>,newValue,oldValue)<br>&#125;) <br><br><span class="hljs-comment">/* 情况三：监视reactive定义的响应式数据</span><br><span class="hljs-comment">若watch监视的是reactive定义的响应式数据，则无法正确获得oldValue！！</span><br><span class="hljs-comment">若watch监视的是reactive定义的响应式数据，则强制开启了深度监视 </span><br><span class="hljs-comment">*/</span><br><span class="hljs-title function_">watch</span>(person,<span class="hljs-function">(<span class="hljs-params">newValue,oldValue</span>)=&gt;</span>&#123;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;person变化了&#x27;</span>,newValue,oldValue)<br>&#125;,&#123;<span class="hljs-attr">immediate</span>:<span class="hljs-literal">true</span>,<span class="hljs-attr">deep</span>:<span class="hljs-literal">false</span>&#125;) <span class="hljs-comment">//此处的deep配置不再奏效</span><br><br><span class="hljs-comment">//情况四：监视reactive定义的响应式数据中的某个属性</span><br><span class="hljs-title function_">watch</span>(<span class="hljs-function">()=&gt;</span>person.<span class="hljs-property">job</span>,<span class="hljs-function">(<span class="hljs-params">newValue,oldValue</span>)=&gt;</span>&#123;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;person的job变化了&#x27;</span>,newValue,oldValue)<br>&#125;,&#123;<span class="hljs-attr">immediate</span>:<span class="hljs-literal">true</span>,<span class="hljs-attr">deep</span>:<span class="hljs-literal">true</span>&#125;) <br><br><span class="hljs-comment">//情况五：监视reactive定义的响应式数据中的某些属性</span><br><span class="hljs-title function_">watch</span>([<span class="hljs-function">()=&gt;</span>person.<span class="hljs-property">job</span>,<span class="hljs-function">()=&gt;</span>person.<span class="hljs-property">name</span>],<span class="hljs-function">(<span class="hljs-params">newValue,oldValue</span>)=&gt;</span>&#123;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;person的job变化了&#x27;</span>,newValue,oldValue)<br>&#125;,&#123;<span class="hljs-attr">immediate</span>:<span class="hljs-literal">true</span>,<span class="hljs-attr">deep</span>:<span class="hljs-literal">true</span>&#125;)<br><br><span class="hljs-comment">//特殊情况</span><br><span class="hljs-title function_">watch</span>(<span class="hljs-function">()=&gt;</span>person.<span class="hljs-property">job</span>,<span class="hljs-function">(<span class="hljs-params">newValue,oldValue</span>)=&gt;</span>&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;person的job变化了&#x27;</span>,newValue,oldValue)<br>&#125;,&#123;<span class="hljs-attr">deep</span>:<span class="hljs-literal">true</span>&#125;) <span class="hljs-comment">//此处由于监视的是reactive素定义的对象中的某个属性，所以deep配置有效</span><br></code></pre></td></tr></table></figure></li></ul><h3 id="3-watchEffect函数"><a href="#3-watchEffect函数" class="headerlink" title="3.watchEffect函数"></a>3.watchEffect函数</h3><ul><li><p>watch的套路是：既要指明监视的属性，也要指明监视的回调。</p></li><li><p>watchEffect的套路是：不用指明监视哪个属性，监视的回调中用到哪个属性，那就监视哪个属性。</p></li><li><p>watchEffect有点像computed：</p><ul><li>但computed注重的计算出来的值（回调函数的返回值），所以必须要写返回值。</li><li>而watchEffect更注重的是过程（回调函数的函数体），所以不用写返回值。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//watchEffect所指定的回调中用到的数据只要发生变化，则直接重新执行回调。</span><br><span class="hljs-title function_">watchEffect</span>(<span class="hljs-function">()=&gt;</span>&#123;<br>    <span class="hljs-keyword">const</span> x1 = sum.<span class="hljs-property">value</span><br>    <span class="hljs-keyword">const</span> x2 = person.<span class="hljs-property">age</span><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;watchEffect配置的回调执行了&#x27;</span>)<br>&#125;)<br></code></pre></td></tr></table></figure></li></ul><h2 id="8-生命周期"><a href="#8-生命周期" class="headerlink" title="8.生命周期"></a>8.生命周期</h2><div style="border:1px solid black;width:380px;float:left;margin-right:20px;"><strong>vue2.x的生命周期</strong><img src="https://cn.vuejs.org/images/lifecycle.png" alt="lifecycle_2" style="zoom:33%;width:1200px" /></div><div style="border:1px solid black;width:510px;height:985px;float:left"><strong>vue3.0的生命周期</strong><img src="https://v3.cn.vuejs.org/images/lifecycle.svg" alt="lifecycle_2" style="zoom:33%;width:2500px" /></div><p>1</p><ul><li>Vue3.0中可以继续使用Vue2.x中的生命周期钩子，但有有两个被更名：<ul><li><code>beforeDestroy</code>改名为 <code>beforeUnmount</code></li><li><code>destroyed</code>改名为 <code>unmounted</code></li></ul></li><li>Vue3.0也提供了 Composition API 形式的生命周期钩子，与Vue2.x中钩子对应关系如下：<ul><li><code>beforeCreate</code>&#x3D;&#x3D;&#x3D;&gt;<code>setup()</code></li><li><code>created</code>&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&gt;<code>setup()</code></li><li><code>beforeMount</code> &#x3D;&#x3D;&#x3D;&gt;<code>onBeforeMount</code></li><li><code>mounted</code>&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&gt;<code>onMounted</code></li><li><code>beforeUpdate</code>&#x3D;&#x3D;&#x3D;&gt;<code>onBeforeUpdate</code></li><li><code>updated</code> &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&gt;<code>onUpdated</code></li><li><code>beforeUnmount</code> &#x3D;&#x3D;&gt;<code>onBeforeUnmount</code></li><li><code>unmounted</code> &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&gt;<code>onUnmounted</code></li></ul></li></ul><h2 id="9-自定义hook函数"><a href="#9-自定义hook函数" class="headerlink" title="9.自定义hook函数"></a>9.自定义hook函数</h2><ul><li><p>什么是hook？—— 本质是一个函数，把setup函数中使用的Composition API进行了封装。</p></li><li><p>类似于vue2.x中的mixin。</p></li><li><p>自定义hook的优势: 复用代码, 让setup中的逻辑更清楚易懂。</p></li></ul><h2 id="10-toRef"><a href="#10-toRef" class="headerlink" title="10.toRef"></a>10.toRef</h2><ul><li><p>作用：创建一个 ref 对象，其value值指向另一个对象中的某个属性。</p></li><li><p>语法：<code>const name = toRef(person,&#39;name&#39;)</code></p></li><li><p>应用:   要将响应式对象中的某个属性单独提供给外部使用时。</p></li><li><p>扩展：<code>toRefs</code> 与<code>toRef</code>功能一致，但可以批量创建多个 ref 对象，语法：<code>toRefs(person)</code></p></li></ul><h1 id="三、其它-Composition-API"><a href="#三、其它-Composition-API" class="headerlink" title="三、其它 Composition API"></a>三、其它 Composition API</h1><h2 id="1-shallowReactive-与-shallowRef"><a href="#1-shallowReactive-与-shallowRef" class="headerlink" title="1.shallowReactive 与 shallowRef"></a>1.shallowReactive 与 shallowRef</h2><ul><li><p>shallowReactive：只处理对象最外层属性的响应式（浅响应式）。</p></li><li><p>shallowRef：只处理基本数据类型的响应式, 不进行对象的响应式处理。</p></li><li><p>什么时候使用?</p><ul><li>如果有一个对象数据，结构比较深, 但变化时只是外层属性变化 &#x3D;&#x3D;&#x3D;&gt; shallowReactive。</li><li>如果有一个对象数据，后续功能不会修改该对象中的属性，而是生新的对象来替换 &#x3D;&#x3D;&#x3D;&gt; shallowRef。</li></ul></li></ul><h2 id="2-readonly-与-shallowReadonly"><a href="#2-readonly-与-shallowReadonly" class="headerlink" title="2.readonly 与 shallowReadonly"></a>2.readonly 与 shallowReadonly</h2><ul><li>readonly: 让一个响应式数据变为只读的（深只读）。</li><li>shallowReadonly：让一个响应式数据变为只读的（浅只读）。</li><li>应用场景: 不希望数据被修改时。</li></ul><h2 id="3-toRaw-与-markRaw"><a href="#3-toRaw-与-markRaw" class="headerlink" title="3.toRaw 与 markRaw"></a>3.toRaw 与 markRaw</h2><ul><li>toRaw：<ul><li>作用：将一个由<code>reactive</code>生成的<strong style="color:orange">响应式对象</strong>转为<strong style="color:orange">普通对象</strong>。</li><li>使用场景：用于读取响应式对象对应的普通对象，对这个普通对象的所有操作，不会引起页面更新。</li></ul></li><li>markRaw：<ul><li>作用：标记一个对象，使其永远不会再成为响应式对象。</li><li>应用场景:<ol><li>有些值不应被设置为响应式的，例如复杂的第三方类库等。</li><li>当渲染具有不可变数据源的大列表时，跳过响应式转换可以提高性能。</li></ol></li></ul></li></ul><h2 id="4-customRef"><a href="#4-customRef" class="headerlink" title="4.customRef"></a>4.customRef</h2><ul><li><p>作用：创建一个自定义的 ref，并对其依赖项跟踪和更新触发进行显式控制。</p></li><li><p>实现防抖效果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;template&gt;<br>&lt;input type=&quot;text&quot; v-model=&quot;keyword&quot;&gt;<br>&lt;h3&gt;&#123;&#123;keyword&#125;&#125;&lt;/h3&gt;<br>&lt;/template&gt;<br><br>&lt;script&gt;<br>import &#123;ref,customRef&#125; from &#x27;vue&#x27;<br>export default &#123;<br>name:&#x27;Demo&#x27;,<br>setup()&#123;<br>// let keyword = ref(&#x27;hello&#x27;) //使用Vue准备好的内置ref<br>//自定义一个myRef<br>function myRef(value,delay)&#123;<br>let timer<br>//通过customRef去实现自定义<br>return customRef((track,trigger)=&gt;&#123;<br>return&#123;<br>get()&#123;<br>track() //告诉Vue这个value值是需要被“追踪”的<br>return value<br>&#125;,<br>set(newValue)&#123;<br>clearTimeout(timer)<br>timer = setTimeout(()=&gt;&#123;<br>value = newValue<br>trigger() //告诉Vue去更新界面<br>&#125;,delay)<br>&#125;<br>&#125;<br>&#125;)<br>&#125;<br>let keyword = myRef(&#x27;hello&#x27;,500) //使用程序员自定义的ref<br>return &#123;<br>keyword<br>&#125;<br>&#125;<br>&#125;<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure></li></ul><h2 id="5-provide-与-inject"><a href="#5-provide-与-inject" class="headerlink" title="5.provide 与 inject"></a>5.provide 与 inject</h2><img src="https://v3.cn.vuejs.org/images/components_provide.png" style="width:300px" /><ul><li><p>作用：实现<strong style="color:#DD5145">祖与后代组件间</strong>通信</p></li><li><p>套路：父组件有一个 <code>provide</code> 选项来提供数据，后代组件有一个 <code>inject</code> 选项来开始使用这些数据</p></li><li><p>具体写法：</p><ol><li><p>祖组件中：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title function_">setup</span>(<span class="hljs-params"></span>)&#123;<br>......<br>    <span class="hljs-keyword">let</span> car = <span class="hljs-title function_">reactive</span>(&#123;<span class="hljs-attr">name</span>:<span class="hljs-string">&#x27;奔驰&#x27;</span>,<span class="hljs-attr">price</span>:<span class="hljs-string">&#x27;40万&#x27;</span>&#125;)<br>    <span class="hljs-title function_">provide</span>(<span class="hljs-string">&#x27;car&#x27;</span>,car)<br>    ......<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>后代组件中：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title function_">setup</span>(<span class="hljs-params">props,context</span>)&#123;<br>......<br>    <span class="hljs-keyword">const</span> car = <span class="hljs-title function_">inject</span>(<span class="hljs-string">&#x27;car&#x27;</span>)<br>    <span class="hljs-keyword">return</span> &#123;car&#125;<br>......<br>&#125;<br></code></pre></td></tr></table></figure></li></ol></li></ul><h2 id="6-响应式数据的判断"><a href="#6-响应式数据的判断" class="headerlink" title="6.响应式数据的判断"></a>6.响应式数据的判断</h2><ul><li>isRef: 检查一个值是否为一个 ref 对象</li><li>isReactive: 检查一个对象是否是由 <code>reactive</code> 创建的响应式代理</li><li>isReadonly: 检查一个对象是否是由 <code>readonly</code> 创建的只读代理</li><li>isProxy: 检查一个对象是否是由 <code>reactive</code> 或者 <code>readonly</code> 方法创建的代理</li></ul><h1 id="四、Composition-API-的优势"><a href="#四、Composition-API-的优势" class="headerlink" title="四、Composition API 的优势"></a>四、Composition API 的优势</h1><h2 id="1-Options-API-存在的问题"><a href="#1-Options-API-存在的问题" class="headerlink" title="1.Options API 存在的问题"></a>1.Options API 存在的问题</h2><p>使用传统OptionsAPI中，新增或者修改一个需求，就需要分别在data，methods，computed里修改 。</p><div style="width:600px;height:370px;overflow:hidden;float:left">    <img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f84e4e2c02424d9a99862ade0a2e4114~tplv-k3u1fbpfcp-watermark.image" style="width:600px;float:left" /></div><div style="width:300px;height:370px;overflow:hidden;float:left">    <img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e5ac7e20d1784887a826f6360768a368~tplv-k3u1fbpfcp-watermark.image" style="zoom:50%;width:560px;left" /> </div><h2 id="2-Composition-API-的优势"><a href="#2-Composition-API-的优势" class="headerlink" title="2.Composition API 的优势"></a>2.Composition API 的优势</h2><p>我们可以更加优雅的组织我们的代码，函数。让相关功能的代码更加有序的组织在一起。</p><div style="width:500px;height:340px;overflow:hidden;float:left">    <img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bc0be8211fc54b6c941c036791ba4efe~tplv-k3u1fbpfcp-watermark.image"style="height:360px"/></div><div style="width:430px;height:340px;overflow:hidden;float:left">    <img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6cc55165c0e34069a75fe36f8712eb80~tplv-k3u1fbpfcp-watermark.image"style="height:360px"/></div><h1 id="五、新的组件"><a href="#五、新的组件" class="headerlink" title="五、新的组件"></a>五、新的组件</h1><h2 id="1-Fragment"><a href="#1-Fragment" class="headerlink" title="1.Fragment"></a>1.Fragment</h2><ul><li>在Vue2中: 组件必须有一个根标签</li><li>在Vue3中: 组件可以没有根标签, 内部会将多个标签包含在一个Fragment虚拟元素中</li><li>好处: 减少标签层级, 减小内存占用</li></ul><h2 id="2-Teleport"><a href="#2-Teleport" class="headerlink" title="2.Teleport"></a>2.Teleport</h2><ul><li><p>什么是Teleport？—— <code>Teleport</code> 是一种能够将我们的<strong style="color:#DD5145">组件html结构</strong>移动到指定位置的技术。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;teleport to=&quot;移动位置&quot;&gt;<br>&lt;div v-if=&quot;isShow&quot; class=&quot;mask&quot;&gt;<br>&lt;div class=&quot;dialog&quot;&gt;<br>&lt;h3&gt;我是一个弹窗&lt;/h3&gt;<br>&lt;button @click=&quot;isShow = false&quot;&gt;关闭弹窗&lt;/button&gt;<br>&lt;/div&gt;<br>&lt;/div&gt;<br>&lt;/teleport&gt;<br></code></pre></td></tr></table></figure></li></ul><h2 id="3-Suspense"><a href="#3-Suspense" class="headerlink" title="3.Suspense"></a>3.Suspense</h2><ul><li><p>等待异步组件时渲染一些额外内容，让应用有更好的用户体验</p></li><li><p>使用步骤：</p><ul><li><p>异步引入组件</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123;defineAsyncComponent&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span><br><span class="hljs-keyword">const</span> <span class="hljs-title class_">Child</span> = <span class="hljs-title function_">defineAsyncComponent</span>(<span class="hljs-function">()=&gt;</span><span class="hljs-title function_">import</span>(<span class="hljs-string">&#x27;./components/Child.vue&#x27;</span>))<br></code></pre></td></tr></table></figure></li><li><p>使用<code>Suspense</code>包裹组件，并配置好<code>default</code> 与 <code>fallback</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;template&gt;<br>&lt;div class=&quot;app&quot;&gt;<br>&lt;h3&gt;我是App组件&lt;/h3&gt;<br>&lt;Suspense&gt;<br>&lt;template v-slot:default&gt;<br>&lt;Child/&gt;<br>&lt;/template&gt;<br>&lt;template v-slot:fallback&gt;<br>&lt;h3&gt;加载中.....&lt;/h3&gt;<br>&lt;/template&gt;<br>&lt;/Suspense&gt;<br>&lt;/div&gt;<br>&lt;/template&gt;<br></code></pre></td></tr></table></figure></li></ul></li></ul><h1 id="六、其他"><a href="#六、其他" class="headerlink" title="六、其他"></a>六、其他</h1><h2 id="1-全局API的转移"><a href="#1-全局API的转移" class="headerlink" title="1.全局API的转移"></a>1.全局API的转移</h2><ul><li><p>Vue 2.x 有许多全局 API 和配置。</p><ul><li><p>例如：注册全局组件、注册全局指令等。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//注册全局组件</span><br><span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">component</span>(<span class="hljs-string">&#x27;MyButton&#x27;</span>, &#123;<br>  <span class="hljs-attr">data</span>: <span class="hljs-function">() =&gt;</span> (&#123;<br>    <span class="hljs-attr">count</span>: <span class="hljs-number">0</span><br>  &#125;),<br>  <span class="hljs-attr">template</span>: <span class="hljs-string">&#x27;&lt;button @click=&quot;count++&quot;&gt;Clicked &#123;&#123; count &#125;&#125; times.&lt;/button&gt;&#x27;</span><br>&#125;)<br><br><span class="hljs-comment">//注册全局指令</span><br><span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">directive</span>(<span class="hljs-string">&#x27;focus&#x27;</span>, &#123;<br>  <span class="hljs-attr">inserted</span>: <span class="hljs-function"><span class="hljs-params">el</span> =&gt;</span> el.<span class="hljs-title function_">focus</span>()<br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li><li><p>Vue3.0中对这些API做出了调整：</p><ul><li><p>将全局的API，即：<code>Vue.xxx</code>调整到应用实例（<code>app</code>）上</p><table><thead><tr><th>2.x 全局 API（<code>Vue</code>）</th><th>3.x 实例 API (<code>app</code>)</th></tr></thead><tbody><tr><td>Vue.config.xxxx</td><td>app.config.xxxx</td></tr><tr><td>Vue.config.productionTip</td><td><strong style="color:#DD5145">移除</strong></td></tr><tr><td>Vue.component</td><td>app.component</td></tr><tr><td>Vue.directive</td><td>app.directive</td></tr><tr><td>Vue.mixin</td><td>app.mixin</td></tr><tr><td>Vue.use</td><td>app.use</td></tr><tr><td>Vue.prototype</td><td>app.config.globalProperties</td></tr></tbody></table></li></ul></li></ul><h2 id="2-其他改变"><a href="#2-其他改变" class="headerlink" title="2.其他改变"></a>2.其他改变</h2><ul><li><p>data选项应始终被声明为一个函数。</p></li><li><p>过度类名的更改：</p><ul><li><p>Vue2.x写法</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.v-enter</span>,<br><span class="hljs-selector-class">.v-leave-to</span> &#123;<br>  <span class="hljs-attribute">opacity</span>: <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-selector-class">.v-leave</span>,<br><span class="hljs-selector-class">.v-enter-to</span> &#123;<br>  <span class="hljs-attribute">opacity</span>: <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>Vue3.x写法</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.v-enter-from</span>,<br><span class="hljs-selector-class">.v-leave-to</span> &#123;<br>  <span class="hljs-attribute">opacity</span>: <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-selector-class">.v-leave-from</span>,<br><span class="hljs-selector-class">.v-enter-to</span> &#123;<br>  <span class="hljs-attribute">opacity</span>: <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li><li><p><strong style="color:#DD5145">移除</strong>keyCode作为 v-on 的修饰符，同时也不再支持<code>config.keyCodes</code></p></li><li><p><strong style="color:#DD5145">移除</strong><code>v-on.native</code>修饰符</p><ul><li><p>父组件中绑定事件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;my-component<br>  v-on:close=&quot;handleComponentEvent&quot;<br>  v-on:click=&quot;handleNativeClickEvent&quot;<br>/&gt;<br></code></pre></td></tr></table></figure></li><li><p>子组件中声明自定义事件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;script&gt;<br>  export default &#123;<br>    emits: [&#x27;close&#x27;]<br>  &#125;<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure></li></ul></li><li><p><strong style="color:#DD5145">移除</strong>过滤器（filter）</p><blockquote><p>过滤器虽然这看起来很方便，但它需要一个自定义语法，打破大括号内表达式是 “只是 JavaScript” 的假设，这不仅有学习成本，而且有实现成本！建议用方法调用或计算属性去替换过滤器。</p></blockquote></li><li><p>……</p></li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>使用Java操作redis基础篇</title>
    <link href="/2022/08/10/%E4%BD%BF%E7%94%A8Java%E6%93%8D%E4%BD%9Credis%E5%9F%BA%E7%A1%80%E7%AF%87/"/>
    <url>/2022/08/10/%E4%BD%BF%E7%94%A8Java%E6%93%8D%E4%BD%9Credis%E5%9F%BA%E7%A1%80%E7%AF%87/</url>
    
    <content type="html"><![CDATA[<h1 id="redis客户端"><a href="#redis客户端" class="headerlink" title="redis客户端"></a>redis客户端</h1><p>redis是一个很强大的NoSQL数据库，它分别拥有支持多种语言的客户端，Java语言就是其中之一。redis是一个单线程的NoSql数据库，主要用来做数据缓存，一般大型网站和数据库之间的那一层就是Redis，比如京东商城的页面查找功能，用户接触的第一层就是Redis数据缓存层，缓存中找不到的数据再进入数据库查询。redis中缓存热点数据，能够保护数据库，提高查询效率。</p><p>关于在java项目中去使用redis，官方（<a href="https://redis.io/docs/clients/#java">https://redis.io/docs/clients/#java</a> ）推荐我们使用前三种Redisson、Jedis、Lettuce客户端，那么他们分别有何优缺点，我们又该如何选择呢？</p><ul><li>Redisson是一个基于Redis实现的分布式、可伸缩的Java数据结构集合。包含了诸如Map、Queue、Lock、 Semaphore、AtomicLong等强大功能</li><li>Jedis以Redis命令作为方法名称，学习成本低，简单实用。但是Jedis实例是线程不安全的，多线程环境下必须需要使用连接池来连接</li><li>Lettuce是基于Netty实现的，支持同步、异步和响应式编程方式，并且是线程安全的。支持Redis的哨兵模式、集群模式和管道模式</li></ul><p>一般使用一下两种方式。</p><h2 id="SpringBoot整合Jedis"><a href="#SpringBoot整合Jedis" class="headerlink" title="SpringBoot整合Jedis"></a>SpringBoot整合Jedis</h2><ol><li><p>引入jedis依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--jedis依赖--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>redis.clients<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>jedis<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.7.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p>与redis建立连接，在Java中的体现就是实例化一个Jedis对象，构造器的参数需要虚拟机的ip地址也就是redis服务器的地址</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"> <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">jedisTest</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-comment">// 建立jedis连接</span><br>        <span class="hljs-type">Jedis</span> <span class="hljs-variable">jedis</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Jedis</span>(<span class="hljs-string">&quot;192.168.9.63&quot;</span>, <span class="hljs-number">6379</span>);<br><br>        Map&lt;String, String&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;String, String&gt;();<br>        map.put(<span class="hljs-string">&quot;id&quot;</span>, <span class="hljs-string">&quot;1&quot;</span>);<br>        map.put(<span class="hljs-string">&quot;username&quot;</span>, <span class="hljs-string">&quot;zhagnsan&quot;</span>);<br>        map.put(<span class="hljs-string">&quot;age&quot;</span>, <span class="hljs-string">&quot;20&quot;</span>);<br>        <span class="hljs-comment">// 存入数据</span><br><span class="hljs-comment">//        jedis.hset(&quot;wangcong&quot;,map); //当前redis版本3.0.5 不支持这样写 会报redis.clients.jedis.exceptions.JedisDataException: ERR wrong number of arguments for &#x27;hset&#x27; command</span><br>        jedis.set(<span class="hljs-string">&quot;wangcong&quot;</span>,map.toString());<br><span class="hljs-comment">//        // 获取命令</span><br><span class="hljs-comment">//        Set&lt;String&gt; userKeys = jedis.hkeys(&quot;wangcong&quot;);</span><br><span class="hljs-comment">//        List&lt;String&gt; userValues = jedis.hvals(&quot;wangcong&quot;);</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">messiah</span> <span class="hljs-operator">=</span> jedis.get(<span class="hljs-string">&quot;messiah&quot;</span>);<br>        <span class="hljs-type">String</span> <span class="hljs-variable">wangcong</span> <span class="hljs-operator">=</span> jedis.get(<span class="hljs-string">&quot;wangcong&quot;</span>);<br>        <span class="hljs-comment">//关闭jedis连接</span><br>        jedis.close();<br>        <span class="hljs-comment">// 输出获取的结果</span><br>        System.out.println(messiah);<br>        System.out.println(<span class="hljs-string">&quot;============================&quot;</span>);<br>        System.out.println(wangcong);<br>    &#125;<br></code></pre></td></tr></table></figure></li><li><p>上面说过Jedis本身是线程不安全的，如果在多线程并发操作下极有可能出现线程安全问题，因此在并发的环境下，一定要为每一个线程创建一个独立的线程对象。但是频繁的创建销毁连接会导致性能损耗，因此需要使用到Jedis连接池来代替Jedis的直接连接方式。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">JedisConnectionFactory</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> JedisPool JEDIS_POOL;<br>    <span class="hljs-keyword">static</span> &#123;<br>        <span class="hljs-comment">// 配置连接池</span><br>        <span class="hljs-type">JedisPoolConfig</span> <span class="hljs-variable">jedisPoolConfig</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">JedisPoolConfig</span>();<br>        <span class="hljs-comment">// 设置最大连接数、最大空闲连接、最小空闲连接、设置无连接的等待时间(毫秒为单位)</span><br>        jedisPoolConfig.setMaxTotal(<span class="hljs-number">8</span>);<br>        jedisPoolConfig.setMaxIdle(<span class="hljs-number">8</span>);<br>        jedisPoolConfig.setMinIdle(<span class="hljs-number">0</span>);<br>        jedisPoolConfig.setMaxWaitMillis(<span class="hljs-number">1000</span>);<br>        <span class="hljs-comment">// 创建连接池对象</span><br>        JEDIS_POOL = <span class="hljs-keyword">new</span> <span class="hljs-title class_">JedisPool</span>(jedisPoolConfig, <span class="hljs-string">&quot;192.168.9.63&quot;</span>, <span class="hljs-number">6379</span>, <span class="hljs-number">1000</span>);<br>    &#125;<br>    <span class="hljs-comment">//在使用的直接调用静态方法即可获取jedis连接</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Jedis <span class="hljs-title function_">getJedis</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> JEDIS_POOL.getResource();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h2 id="Springboot整合RedisTemplate"><a href="#Springboot整合RedisTemplate" class="headerlink" title="Springboot整合RedisTemplate"></a>Springboot整合RedisTemplate</h2><ol><li>引入相关依赖</li></ol>   <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java">由于使用到了JSON所以需要导入相关依赖进行序列化<br>&lt;dependency&gt;<br>    &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;<br>    &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt;<br>&lt;/dependency&gt;<br>redis<br>&lt;dependency&gt;<br>    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;<br>    &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;<br>&lt;/dependency&gt;<br></code></pre></td></tr></table></figure><p>   RedisConfig：</p>   <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.messiah.springbootredis.config;<br><br><span class="hljs-keyword">import</span> com.fasterxml.jackson.annotation.JsonAutoDetect;<br><span class="hljs-keyword">import</span> com.fasterxml.jackson.annotation.PropertyAccessor;<br><span class="hljs-keyword">import</span> com.fasterxml.jackson.databind.ObjectMapper;<br><span class="hljs-keyword">import</span> jdk.nashorn.internal.objects.annotations.Property;<br><span class="hljs-keyword">import</span> org.springframework.cache.CacheManager;<br><span class="hljs-keyword">import</span> org.springframework.cache.annotation.CachingConfigurerSupport;<br><span class="hljs-keyword">import</span> org.springframework.cache.annotation.EnableCaching;<br><span class="hljs-keyword">import</span> org.springframework.context.annotation.Bean;<br><span class="hljs-keyword">import</span> org.springframework.context.annotation.Configuration;<br><span class="hljs-keyword">import</span> org.springframework.data.redis.cache.RedisCacheConfiguration;<br><span class="hljs-keyword">import</span> org.springframework.data.redis.cache.RedisCacheManager;<br><span class="hljs-keyword">import</span> org.springframework.data.redis.connection.RedisConnectionFactory;<br><span class="hljs-keyword">import</span> org.springframework.data.redis.core.RedisTemplate;<br><span class="hljs-keyword">import</span> org.springframework.data.redis.hash.ObjectHashMapper;<br><span class="hljs-keyword">import</span> org.springframework.data.redis.serializer.Jackson2JsonRedisSerializer;<br><span class="hljs-keyword">import</span> org.springframework.data.redis.serializer.RedisSerializationContext;<br><span class="hljs-keyword">import</span> org.springframework.data.redis.serializer.RedisSerializer;<br><span class="hljs-keyword">import</span> org.springframework.data.redis.serializer.StringRedisSerializer;<br><span class="hljs-keyword">import</span> java.time.Duration;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@PackageName</span>: com.messiah.springbootredis.config</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@ClassName</span>: redisConfig</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Description</span>: 使用配置类替代默认的序列化配置</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Author</span>: wangcong</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Date</span>: 22-8-10 09:35</span><br><span class="hljs-comment"> **/</span><br><span class="hljs-meta">@EnableCaching</span> <span class="hljs-comment">//开启缓存</span><br><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">redisConfig</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">CachingConfigurerSupport</span> &#123;<br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> RedisTemplate&lt;String,Object&gt; <span class="hljs-title function_">redisTemplate</span><span class="hljs-params">(RedisConnectionFactory factory)</span>&#123;<br>        <span class="hljs-comment">//创建redisTemplate对象</span><br>        RedisTemplate&lt;String,Object&gt; template = <span class="hljs-keyword">new</span> <span class="hljs-title class_">RedisTemplate</span>&lt;&gt;();<br>        RedisSerializer&lt;String&gt; stringRedisSerializer = <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringRedisSerializer</span>();<br>        <span class="hljs-comment">//创建json序列化工具</span><br>        <span class="hljs-type">Jackson2JsonRedisSerializer</span> <span class="hljs-variable">jackson2JsonRedisSerializer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Jackson2JsonRedisSerializer</span>(Object.class);<br>        <span class="hljs-comment">//创建ObjectMapper对象用于序列化和反序列化</span><br>        <span class="hljs-type">ObjectMapper</span> <span class="hljs-variable">om</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectMapper</span>();<br>        om.setVisibility(PropertyAccessor.ALL,JsonAutoDetect.Visibility.ANY);<br>        om.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL);<br>        jackson2JsonRedisSerializer.setObjectMapper(om);<br>        <span class="hljs-comment">//设置连接工厂</span><br>        template.setConnectionFactory(factory);<br>        <span class="hljs-comment">//key序列化方式</span><br>        template.setKeySerializer(stringRedisSerializer);<br>        <span class="hljs-comment">//value序列化</span><br>        template.setValueSerializer(jackson2JsonRedisSerializer);<br>        <span class="hljs-comment">//value hashmap序列化</span><br>        template.setHashValueSerializer(jackson2JsonRedisSerializer);<br>        <span class="hljs-keyword">return</span> template;<br>    &#125;<br><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> CacheManager <span class="hljs-title function_">cacheManager</span><span class="hljs-params">(RedisConnectionFactory factory)</span> &#123;<br>        RedisSerializer&lt;String&gt; redisSerializer = <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringRedisSerializer</span>();<br>        <span class="hljs-type">Jackson2JsonRedisSerializer</span> <span class="hljs-variable">jackson2JsonRedisSerializer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Jackson2JsonRedisSerializer</span>(Object.class);<br>        <span class="hljs-comment">//解决查询缓存转换异常的问题</span><br>        <span class="hljs-type">ObjectMapper</span> <span class="hljs-variable">om</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectMapper</span>();<br>        om.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY);<br>        om.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL);<br>        jackson2JsonRedisSerializer.setObjectMapper(om);<br>        <span class="hljs-comment">// 配置序列化（解决乱码的问题）,过期时间600秒</span><br>        <span class="hljs-type">RedisCacheConfiguration</span> <span class="hljs-variable">config</span> <span class="hljs-operator">=</span> RedisCacheConfiguration.defaultCacheConfig()<br>                .entryTtl(Duration.ofSeconds(<span class="hljs-number">600</span>))  <span class="hljs-comment">//设置数据过期时间600秒</span><br>                .serializeKeysWith(RedisSerializationContext.SerializationPair.fromSerializer(redisSerializer))   .serializeValuesWith(RedisSerializationContext.SerializationPair.fromSerializer(jackson2JsonRedisSerializer))<br>                .disableCachingNullValues();<br>        <span class="hljs-type">RedisCacheManager</span> <span class="hljs-variable">cacheManager</span> <span class="hljs-operator">=</span> RedisCacheManager.builder(factory)<br>                .cacheDefaults(config)<br>                .build();<br>        <span class="hljs-keyword">return</span> cacheManager;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>   读写数据</p>   <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">注意使用的地方需要注入<br><span class="hljs-meta">@Autowired</span><br><span class="hljs-keyword">private</span> RedisTemplate redisTemplate;<br>......<br>redisTemplate.opsForValue().set(<span class="hljs-string">&quot;name&quot;</span>,<span class="hljs-string">&quot;nb&quot;</span>);<br>redisTemplate.opsForValue().get(<span class="hljs-string">&quot;name&quot;</span>);<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Linux笔记</title>
    <link href="/2022/08/04/Linux%E7%AC%94%E8%AE%B0/"/>
    <url>/2022/08/04/Linux%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="linux笔记"><a href="#linux笔记" class="headerlink" title="linux笔记"></a>linux笔记</h1><p>linux的文件结构是树形结构</p><p>根目录为 &#x2F; </p><p>linux下一些主要目录的作用</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli"><span class="hljs-string">/bin</span> 二进制可执行命令<br><span class="hljs-string">/dev</span> 设备特殊文件<br><span class="hljs-string">/boot</span> 系统内核及启动有关的文件<br><span class="hljs-string">/etc</span> 系统管理和配置文件<br><span class="hljs-string">/etc/rc.d</span> 启动的配置文件和脚本<br><span class="hljs-string">/home</span> 用户主目录的根点，比如用户user的主目录就是<span class="hljs-string">/home/user</span>,可以用~user表示<br><span class="hljs-string">/lib</span> 标准程序设计库，又叫动态链接共享库，作用类似于windows里的<span class="hljs-string">.dll</span>文件<br><span class="hljs-string">/sbin</span> 系统管理命令，这里存放的是系统管理员使用的程序<br><span class="hljs-string">/tmp</span> 公用的临时文件存储点<br><span class="hljs-string">/root</span> 系统管理员的主目录<br><span class="hljs-string">/mnt</span> 系统提供这个目录是让用户临时挂载其他的文件系统<br><span class="hljs-string">/lost</span>+found 这个目录平时是空的，系统非正常关机而留下“无家可归”的文件<span class="hljs-params">(windows下叫什么.chk)</span>就在这里<br><span class="hljs-string">/proc</span> 虚拟的目录，是系统内存的映射。可直接访问这个目录来获取系统信　　息。<br><span class="hljs-string">/var</span> 某些大文件的溢出区，比方说各种服务的日志文件, 存放系统运行中常改变的文件，如系统日志<br><span class="hljs-string">/usr</span> 最庞大的目录，要用到的应用程序和文件几乎都在这个目录。其中包　　含：<br><span class="hljs-string">/usr/X11R6</span> 存放X window的目录<br><span class="hljs-string">/usr/bin</span> 众多的应用程序<br><span class="hljs-string">/usr/sbin</span> 超级用户的一些管理程序<br><span class="hljs-string">/usr/doc</span> linux文档<br><span class="hljs-string">/usr/include</span> linux下开发和编译应用程序所需要的头文件<br><span class="hljs-string">/usr/lib</span> 常用的动态链接库和软件包的配置文件<br><span class="hljs-string">/usr/man</span> 帮助文档<br><span class="hljs-string">/usr/src</span> 源代码，linux内核的源代码就放在<span class="hljs-string">/usr/src/linux</span>里<br><span class="hljs-string">/usr/local/bin</span> 本地增加的命令<br><span class="hljs-string">/usr/local/lib</span> 本地增加的库<br></code></pre></td></tr></table></figure><p>家目录：在home下每个普通用户都有一个以用户名命名的目录，这个就是家目录 如：&#x2F;home&#x2F;user 等价于 ~，每个用户只能在自己的家目录下创建文件、修改文件等， 不能修改其他用户家目录中的文件。</p><p>命令行界面</p><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs gherkin">[root<span class="hljs-meta">@localhost</span> ~]<span class="hljs-comment">#</span><br>root : 表示当前用户的名称<br><span class="hljs-meta">@：分隔符</span><br>localhost：当前主机的主机名<br>~：用户当前所在的目录名称 显示~表示当前目录即为用户家目录<br><span class="hljs-comment">#：用户身份提示符，#表示超级用户，也就是管理员 $表示普通用户</span><br></code></pre></td></tr></table></figure><p>linux常用命令</p><ol><li><p>简单系统命令</p><p><code>ip a</code>:查看ip地址<br><code>ip 目标机器的ip</code>:ping网络(测试网络连通)<br><code>date</code>:查看系统时间<br><code>logout</code>:注销<br><code>shutdown now</code>:关机<br><code>reboot</code>:重启<br><code>clear</code>:清屏</p></li><li><p>文件管理命令</p><ol><li><p>查看文件列表</p><p><code>ls</code>:查看当前目录下的文件列表</p><p><code>ls /</code>:查看指定目录下的文件</p><p><code>ls -l</code>:查看详细信息，元数据信息(用户、组、大小、创建时间、权限信息、文件类型)</p><p><code>ls -a</code>:查看隐藏文件</p><p><code>ls -la</code>:参数并用</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">ls</span>会显示出文件的颜色, 系统约定的默认颜色含义如下:<br>白色：表示普通文件<br>蓝色：表示目录<br>绿色：表示可执行文件<br>红色：表示压缩文件<br>浅蓝色：链接文件 主要是使用<span class="hljs-built_in">ln</span>命令建立的文件<br>红色闪烁：表示链接的文件有问题<br>黄色：表示设备文件<br>灰色：表示其他文件<br></code></pre></td></tr></table></figure></li><li><p>切换目录</p><p><code>cd 目标文件夹</code>:切换目录 目标文件夹可以是绝对路径或者相对路径都行</p></li><li><p><code>pwd</code>查看当前命令所在的目录</p></li><li><p>新建文件夹及文件</p><p><code>mkdir 文件夹名</code>:在当前位置新建文件夹</p><p><code>mkdir -p /a/b/文件夹名</code>:在指定目录位置，创建文件夹，并创建父文件夹</p><p><code>touch 文件名</code>:在当前目录下新建文件</p></li><li><p>删除文件</p><p><code>rm 文件</code>:删除文件</p><p><code>rm -r 文件夹</code>:删除文件夹</p><p><code>rm -rf 文件</code>:强制删除不询问</p></li><li><p>拷贝文件</p><p><code>cp 原文件  新文件</code>:拷贝文件</p><p><code>cp -r 源文件夹 新文件夹</code>:拷贝文件夹</p></li><li><p>移动文件或修改文件名</p><p><code>mv 文件  文件夹</code>:移动源文件到目标文件夹中</p><p><code>mv 文件A 文件B</code>:修改文件A的名字为文件B</p></li><li><p>获取文件的md5指纹(数字签名)</p><p><code>md5sum 文件名</code>:获取文件的md5指纹,数字签名,又称数字指纹,可以验证文件是否被修改,一个文件通过计算得到的一串字符串,文件内容的唯一标记(文件内容不变,指纹不会变)</p></li></ol></li><li><p>文件内容查看命令</p><p>​<code>cat 文件名</code>:查看文件中的全部信息(适合查看小文档)</p><p>​<code>less 文件名</code>:以分页的方式浏览文件信息(适合查看大文档)，进入浏览模式。浏览模式快捷键 ↑ 上一行    ↓ 下一行   G 最后一页    g 第一页    空格 下一页    &#x2F;关键词 搜索关键词  q 退出浏览模式，回到Linux命令行模式</p><p>​<code>tail -f 文件名</code>:实时滚动显示文件的最后10行信息(默认10行)</p><p>​<code>tail -n 20 文件名</code>:显示文件的最后20行信息</p><p>​<code>tail -n +20 文件名</code>:显示文件信息从第20行至文件末尾</p></li><li><p>文件查找</p><ol><li><p>文件名查找</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-comment"># 语法</span><br><span class="hljs-built_in">find</span> 搜索路径 -name <span class="hljs-string">&quot;文件名关键词&quot;</span><br><span class="hljs-comment"># 例子</span><br><span class="hljs-built_in">find</span> / -name <span class="hljs-string">&quot;passwd&quot;</span><br><span class="hljs-built_in">find</span> / -name <span class="hljs-string">&quot;ifcfg-*&quot;</span><br></code></pre></td></tr></table></figure></li><li><p>文件内容查找</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-comment"># 语法</span><br><span class="hljs-keyword">grep</span> -参数 要查找的目录范围<br><span class="hljs-comment"># 参数</span><br>-n 显示查找结果所在行号<br>-R 递归查找目录下的所有文件<br><span class="hljs-comment"># 例子</span><br><span class="hljs-keyword">grep</span> aries /etc<br><span class="hljs-keyword">grep</span> aries /etc/passwd<br></code></pre></td></tr></table></figure></li></ol></li><li><p>系统管理</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-comment"># 静态查看系统进程</span><br><span class="hljs-built_in">ps</span> <span class="hljs-literal">-aux</span><br><span class="hljs-comment"># 查找指定进程</span><br><span class="hljs-built_in">ps</span> <span class="hljs-literal">-ef</span> | grep 进程关键字<br><span class="hljs-comment"># 显示指定用户的进程信息</span><br><span class="hljs-built_in">ps</span> <span class="hljs-literal">-u</span> root  <span class="hljs-comment">#显示指定用户的进程信息</span><br><span class="hljs-comment"># 实时查看系统进程</span><br>top<br><span class="hljs-comment"># 快捷键</span><br>↑ 下翻<br>↓ 上翻<br>q 退出<br><span class="hljs-comment"># 关闭进程</span><br><span class="hljs-built_in">kill</span> 进程id <br><span class="hljs-comment"># 强制关闭进程(谨慎使用)</span><br><span class="hljs-built_in">kill</span> <span class="hljs-literal">-9</span> 进程id<br></code></pre></td></tr></table></figure></li><li><p>输出</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs applescript"><span class="hljs-comment"># 覆盖输出</span><br><span class="hljs-comment"># 将命令1的执行结果，输出到后面的文件中。</span><br>`覆盖写入`<br>命令<span class="hljs-number">1</span> &gt; 文件<br><span class="hljs-comment"># 例子</span><br><span class="hljs-built_in">date</span> &gt; <span class="hljs-built_in">date</span>.<span class="hljs-built_in">log</span><br><br><span class="hljs-comment"># 追加输出</span><br><span class="hljs-comment"># 将命令1的执行结果，输出到后面的文件中。</span><br>`追加写入`<br>命令<span class="hljs-number">1</span> &gt;&gt; 文件<br><span class="hljs-comment"># 例子</span><br><span class="hljs-built_in">date</span> &gt;&gt; <span class="hljs-built_in">date</span>.<span class="hljs-built_in">log</span><br></code></pre></td></tr></table></figure></li><li><p>管道</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs 1c"><span class="hljs-meta"># 管道</span><br><span class="hljs-meta"># 语法，将命令1的输出结果，作为命令2的输入</span><br>命令<span class="hljs-number">1</span> <span class="hljs-string">| 命令2</span><br><span class="hljs-meta"># 例子</span><br>查找aries用户：cat /etc/passwd <span class="hljs-string">| grep -n “baizhi”</span><br>查找aries组：cat /etc/group <span class="hljs-string">| grep -n “baizhi”</span><br>查找sshd进程：ps -aux <span class="hljs-string">| grep sshd</span><br></code></pre></td></tr></table></figure></li></ol><p><a href="https://blog.csdn.net/weixin_44191814/article/details/120091363">https://blog.csdn.net/weixin_44191814/article/details/120091363</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>TypeScript笔记</title>
    <link href="/2022/08/01/TypeScript%E7%AC%94%E8%AE%B0/"/>
    <url>/2022/08/01/TypeScript%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="TypeScript笔记"><a href="#TypeScript笔记" class="headerlink" title="TypeScript笔记"></a>TypeScript笔记</h1><p>首先，ts是作为js的升级进阶版，是一个超集，并且ts区别于js最大的不同我认为就是，js是一门弱类型的语言，所以写起来语法灰常奔放，而我们的ts就不同ts是一门强类型的语言。完善了js所缺失的接口、继承、强类型等。</p><p>ts通过类型注解提供编译时的静态类型检查。</p><p>定义数据类型变量：let bookNum:number &#x3D; 12</p><p>定义字符串数组：let books:String[] &#x3D; [“圣经”,”messiah”]</p><p>interface 进行自定义静态类型</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">SpecialtyFood</span> &#123;<br><span class="hljs-attr">name</span>:<span class="hljs-title class_">String</span>,<br><span class="hljs-attr">price</span>:<span class="hljs-built_in">number</span>,<br><span class="hljs-attr">describe</span>:<span class="hljs-title class_">String</span><br>&#125;<br></code></pre></td></tr></table></figure><p>定义对象</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">let</span> <span class="hljs-attr">bookInfo</span>:&#123;<br><span class="hljs-attr">name</span>:<span class="hljs-title class_">String</span>,<br><span class="hljs-attr">author</span>:<span class="hljs-title class_">String</span>,<br><span class="hljs-attr">bookType</span>:<span class="hljs-title class_">String</span><br>&#125;=&#123;<span class="hljs-attr">name</span>:<span class="hljs-string">&quot;圣经&quot;</span>,<span class="hljs-attr">author</span>:<span class="hljs-string">&quot;messiah&quot;</span>,<span class="hljs-attr">bookType</span>:<span class="hljs-string">&quot;宗教&quot;</span>&#125;<br><span class="hljs-keyword">let</span> <span class="hljs-attr">hotpot</span>:<span class="hljs-title class_">SpecialtyFood</span> = &#123;<span class="hljs-attr">name</span>:<span class="hljs-string">&quot;麻辣香锅&quot;</span>,<span class="hljs-attr">price</span>:<span class="hljs-number">180</span>,<span class="hljs-attr">describe</span>:<span class="hljs-string">&quot;又麻又辣又香！&quot;</span>&#125;<br></code></pre></td></tr></table></figure><p>声明一个类</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span>&#123;&#125;<br><span class="hljs-keyword">let</span> <span class="hljs-attr">messiah</span>:<span class="hljs-title class_">Person</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>()<br></code></pre></td></tr></table></figure><p>函数类型注解</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-comment">//函数参数和返回类型的注解</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">count1</span>(<span class="hljs-params">a:<span class="hljs-built_in">number</span>,b:<span class="hljs-built_in">number</span></span>):<span class="hljs-built_in">number</span>&#123;<br>    <span class="hljs-keyword">return</span> a+b;<br>&#125;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">count2</span>(<span class="hljs-params">a:<span class="hljs-built_in">number</span>,b:<span class="hljs-built_in">String</span></span>):<span class="hljs-title class_">String</span>&#123;<br>    <span class="hljs-keyword">return</span> a+b;<br>&#125;<br><span class="hljs-comment">//当函数的参数是对象的时候，确定对象中参数的类型需要对对象中的每个属性进行声明</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">count3</span>(<span class="hljs-params">&#123;a,b&#125;:&#123;a:<span class="hljs-built_in">number</span>,b:<span class="hljs-built_in">number</span>&#125;</span>):<span class="hljs-built_in">number</span>&#123;<br>    <span class="hljs-keyword">return</span> a+b;<br>&#125;<br></code></pre></td></tr></table></figure><p>关于ts中函数的返回值除了js的数据类型外还有一个never，如果函数永远执行不完，或者存在错误或者异常（存在无法到达的终点），函数的返回值需要用到never。never类型表示的是哪些永不存在的值的类型。neve可以赋值给任意类型，但是任意类型不能赋值给never类型。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript">补充说明一下：js的数据类型<br>js的数据类型大致分为基本数据类型和引用数据类型<br>基本数据类型（值类型）：字符串（<span class="hljs-title class_">String</span>），数字（<span class="hljs-title class_">Number</span>），布尔（<span class="hljs-title class_">Boolean</span>），对空（<span class="hljs-title class_">Null</span>），未定义（<span class="hljs-title class_">Undefined</span>）。<br>引用数据类型（对象类型）：对象（<span class="hljs-title class_">Object</span>），数组（<span class="hljs-title class_">Array</span>），函数（<span class="hljs-title class_">Function</span>）。<br>特殊的对象：正则（<span class="hljs-title class_">RegExp</span>），日期（<span class="hljs-title class_">Date</span>）。<br>特殊类型：<span class="hljs-literal">undefined</span> 未定义、<span class="hljs-title class_">Null</span> 空对象、<span class="hljs-title class_">Infinate</span> 无穷、<span class="hljs-variable constant_">NAN</span> 非数字<br><br>基本数据类型的值直接在栈内存中存储，值与值之间独立存在，修改一个变量不会影响到其他变量。<br>对象是保存在堆内存中的，每创建一个新对象，就会再堆内存中开辟一块新空间，而变量保存的是对象的内存地址（对象的引用）,如果两个变量保存的是同一个对象的引用，当其中一个通过变量修改属性的时候，另一个也会受到影响。<br><br>挡比较两个基本数据类的值是，就是比较值。比较两个引用数据类型是，比较的是对象的内存地址，如果两个对象是一样但是地址不同，也是<span class="hljs-literal">false</span><br>js的数据类型：<span class="hljs-attr">https</span>:<span class="hljs-comment">//blog.csdn.net/m0_67372185/article/details/123980449</span><br></code></pre></td></tr></table></figure><p>数组类型注解</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-comment">//数组中只存在一种类型</span><br><span class="hljs-keyword">let</span> <span class="hljs-attr">arr</span>:<span class="hljs-title class_">String</span>[] = [<span class="hljs-string">&quot;圣经&quot;</span>,<span class="hljs-string">&quot;messiah&quot;</span>]<br><span class="hljs-comment">//数组中存在多种类型数据</span><br><span class="hljs-keyword">let</span> <span class="hljs-attr">arr1</span>:(<span class="hljs-title class_">String</span>|<span class="hljs-built_in">number</span>)[] = [<span class="hljs-string">&quot;messiah&quot;</span>,<span class="hljs-number">520</span>]<br><span class="hljs-comment">//如果数组中存在对象这种比较复杂的时候 使用类型别名，interface，class进行类型限定</span><br><span class="hljs-keyword">type</span> <span class="hljs-title class_">People</span> = &#123;<span class="hljs-comment">//方式一：类型别名</span><br>    <span class="hljs-attr">name</span>:<span class="hljs-title class_">String</span>,<br>    <span class="hljs-attr">age</span>:<span class="hljs-built_in">number</span><br>&#125;<br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">People</span> &#123;<span class="hljs-comment">//方式二：接口</span><br>    <span class="hljs-attr">name</span>:<span class="hljs-title class_">String</span>,<br>    <span class="hljs-attr">age</span>:<span class="hljs-built_in">number</span><br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">People</span>&#123;<span class="hljs-comment">//方式\三：类</span><br>    <span class="hljs-attr">name</span>:<span class="hljs-title class_">String</span>,<br>    <span class="hljs-attr">age</span>:<span class="hljs-built_in">number</span><br>&#125;<br><br><span class="hljs-keyword">let</span> <span class="hljs-attr">peoples</span>:<span class="hljs-title class_">People</span>[] = [&#123;<span class="hljs-string">&quot;messiah&quot;</span>,<span class="hljs-number">18</span>&#125;,&#123;<span class="hljs-string">&quot;张三&quot;</span>,<span class="hljs-number">19</span>&#125;]<br><span class="hljs-comment">//注意：此处类型别名看似和接口类一样其实不然，类型别名也可以只定义一种类型虽然通常不会这么做，形如 type People = String，但是接口不行</span><br></code></pre></td></tr></table></figure><p>ts的基本语法由以下几个部分组成：模块、函数、变量、语句和表达式、注释，使用tsc xxx.ts将我们的ts文件转化为js文件。 </p><h2 id="TypeScript变量声明"><a href="#TypeScript变量声明" class="headerlink" title="TypeScript变量声明"></a>TypeScript变量声明</h2><p>TypeScript的变量命令规则</p><ul><li>变量名称可以包含数字和字母，但是不能以数字作为开头。</li><li>除了下划线_和美元$符号外。不能出现其他特殊字符，包括空格。</li></ul><p>var [变量名]:[类型] &#x3D; 值</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript">声明变量的类型,但是没有初始值，变量值会设置成<span class="hljs-literal">undefined</span><br>声明变量并赋初始值，但不设置类型，该变量可以是任意类型<br>声明变量不设置类型也不初始化值，其实就和js一样，默认值<span class="hljs-literal">undefined</span>，类型 为任意类型<br>需要注意的是 变量的命令要使用name 否则会与dom中的全局<span class="hljs-variable language_">window</span>下的name属性名称冲突<br></code></pre></td></tr></table></figure><p>类型断言（Type Assertion）可以用来手动指定一个值的类型，即允许变量从一种类型更改为另一种类型。</p><p>语法格式：&lt;类型&gt;值 或者 值 as 类型</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs r">TypeScript 是怎么确定单个断言是否足够<br>当 S 类型是 <span class="hljs-built_in">T</span> 类型的子集，或者 <span class="hljs-built_in">T</span> 类型是 S 类型的子集时，S 能被成功断言成 <span class="hljs-built_in">T</span>。这是为了在进行类型断言时提供额外的安全性，完全毫无根据的断言是危险的，如果你想这么做，你可以使用 <span class="hljs-built_in">any</span>。<br>它之所以不被称为类型转换，是因为转换通常意味着某种运行时的支持。但是，类型断言纯粹是一个编译时语法，同时，它也是一种为编译器提供关于如何分析代码的方法。<br></code></pre></td></tr></table></figure><p>类型推断</p><p>当类型没有给出时，TypeScript 编译器利用类型推断来推断类型。</p><p>如果由于缺乏声明而不能推断出类型，那么它的类型被视作默认的动态 any 类型。</p><p>变量作用域</p><p>变量作用域指定了变量定义的位置,程序中变量的可用性由变量作用域决定。</p><p>TypeScript 有以下几种作用域：</p><ul><li><p>全局作用域 − 全局变量定义在程序结构的外部，它可以在你代码的任何位置使用。</p></li><li><p>类作用域 − 这个变量也可以称为 字段。类变量声明在一个类里头，但在类的方法外面。 该变量可以通过类的对象来访问。类变量也可以是静态的，静态的变量可以通过类名直接访问。</p></li><li><p>局部作用域 − 局部变量，局部变量只能在声明它的一个代码块（如：方法）中使用。</p></li></ul><h2 id="TypeScript运算符"><a href="#TypeScript运算符" class="headerlink" title="TypeScript运算符"></a>TypeScript运算符</h2><p>在ts主要包括以下几种运算符</p><figure class="highlight brainfuck"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs brainfuck"><span class="hljs-comment">算术运算符：</span><span class="hljs-literal">+</span> <span class="hljs-literal">-</span> <span class="hljs-comment">* / %</span> <span class="hljs-literal">++</span> <span class="hljs-literal">--</span><br><span class="hljs-comment">逻辑运算符：&amp;&amp; || ！  注意&amp;&amp;和||都存在短路机制</span><br><span class="hljs-comment">关系运算符:  ==  !=</span>  &gt;  &lt;  &gt;<span class="hljs-comment">=</span>  &lt;<span class="hljs-comment">=</span><br><span class="hljs-comment">按位运算符：</span><br><span class="hljs-comment">赋值运算符：</span><br><span class="hljs-comment">三元条件运算符：</span><br><span class="hljs-comment">类型运算符：</span><br></code></pre></td></tr></table></figure><h2 id="TypeScript条件语句"><a href="#TypeScript条件语句" class="headerlink" title="TypeScript条件语句"></a>TypeScript条件语句</h2><h2 id="TypeScript循环"><a href="#TypeScript循环" class="headerlink" title="TypeScript循环"></a>TypeScript循环</h2>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>JAVA笔记</title>
    <link href="/2022/07/25/JAVA%E7%AC%94%E8%AE%B0/"/>
    <url>/2022/07/25/JAVA%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="JavaSE笔记"><a href="#JavaSE笔记" class="headerlink" title="JavaSE笔记"></a>JavaSE笔记</h1><pre><code class="hljs">1.java的历史jdkjava开发工具包jre jave运行环境jvmjava虚拟机</code></pre><p>局部变量，必须声明和初始化<br>布尔值 默认为false<br>除了基本值默认为0其他都为null<br>修饰符final不存在前后循序<br>常量全大写 变量名首字母小写驼峰原则 类名首字母大写驼峰原则<br>&lt;&lt; 左移*2   &gt;&gt; 右移&#x2F;2<br>字符串连接符 +  要注意字符串所在的位置<br>三目运算符 a&gt;b ? x,y a为真返回x，为假返回y<br>包就是文件夹<br>定义包packeg 导入包 import<br>阿里巴巴开发手册规范<br>javadoc生成文档<br>scanner类<br>用scanner对象的next()和nextline()来获取用户输入的字符串，可以用hasnext()和hasnestline()来判断用户是否有下一个输入<br>凡是io流用完记得关掉它 close()<br>next()不可以获得空白，空白作为分隔符或者结束符，而nextline()就可以获得空白，它以回车为结束符，用的比较多</p><p>java的基本结构为顺序结构，总共有三种结构：顺序结构，判断结构，循环结构</p><p>switch 每一个case就要有一个break，不然会出现case穿透现象，输出后面所有值<br>选择结构<br>if单选择<br>if(布尔表达式){<br>    代码块<br>}<br>if多选择<br>if(布尔表达式){<br>    代码块<br>}else{<br>    代码块<br>}<br>多重if结构<br>if(布尔表达式1){<br>    代码块1<br>}else if(布尔表达式2){<br>    代码块2<br>}else if(布尔表达式3){<br>}else{<br>    代码块3<br>}</p><p>循环结构<br>while循环：先判断在执行<br>while(布尔表达式){<br>    循环代码块<br>}</p><p>dowhile循环：先执行一次在判断条件<br>do{<br>    循环代码块<br>}while(布尔表达式)</p><p>for循环：先判断满足条件在执行，是循环中最有效，最灵活的循环结构，循环次数在开始的时候就被确定</p><p>for(初始值,循环条件,迭代器){<br>    代码块<br>}<br>增强for循环 ：重点遍历数组和集合<br>break 用于强制退出循环，不执行循环剩下的语句<br>continue 终止某次循环，既跳过之后的语句，重新回到循环判定</p><h2 id="Java方法详解"><a href="#Java方法详解" class="headerlink" title="Java方法详解"></a>Java方法详解</h2><p>静态方法：不需要示例化 直接类名.方法名调用 用static修饰 是和类一起加载的<br>非静态方法：不需要修饰但一定要示例化创建对象。通过对象.方法名调用<br>return 除了了返回方法结果外还有一个功能就是return 0;终止方法<br>什么是值传递什么是引用传递  java是值传递  java的八大基本数据类型一般都是值传递 靠返回值来修改真是的值信息，而对象数组的话一般都是引用传递<br>    值传递：会复制一份，形参无返回是不会改变实参<br>    引用传递：一般存在与对象 改变的不是形参改变的是对象                                                                                                                                                                                 方法重载：名称相同 参数必须不同(可以是类型不同，个数不同，参数排列顺序不同)发生在本类 返回类型也可以不同或者相同<br>方法重写：名称相同 参数列表相同且返回类型必须相同  发生在父类与子类之间<br>重载：”两同三不同”<br>    同一个类 同一个方法名<br>    参数 不同 类型 顺序 个数</p><p>命令行传参：一定要写上我们的包路径 ，main方法也是可以传参的</p><p>可变参数：…类型要相同，且必须要在参数列表最后一个</p><p>递归：自己调用自己 包含两个部分递归头和递归体   递归头：递归方法的结束，什么时候不调用自身 递归体：什么时候需要调用自身</p><h2 id="Java数组"><a href="#Java数组" class="headerlink" title="Java数组"></a>Java数组</h2><p>数组：想同类型数的有序集合<br>特点：长度是确定，长度一旦确定就不可改变<br>      必须是相同类型的数据<br>      数组中的元素可以是任何类型的数据<br>      数组变量属于引用类型，也可以看成是一个对象，数组中的每个元素可以看成是该对象的成员变量<br>      数组是存放在堆中的，无论数组中的元素类型是基本类型还是引用类型<br>数组的定义两种方法：在类型名后写数组符号，在变量名后面写数组符号  通过new来创建 数组长度要确定<br>静态初始化： int[] a &#x3D; {1,2,3,4}  创建+赋值<br>动态初始化: int[] a &#x3D; new int[4]  包含默认初始化  只是创建但是不会给数组赋值<br>lenth()：求数组长度</p><p>多维数组：相当于数组类的每个元素都是一个数组<br>多维数组的打印要用多个循环</p><p>Arrays类：数组工具类 包含操作数组的各个方法的工具类<br>    tostring()打印数组元素<br>    sort()数组排序默认升序<br>冒泡排序：总共有八种排序 时间复杂度O(n^2)<br>稀疏数组：用来压缩数组，获取有效值</p><h2 id="Java内存分析"><a href="#Java内存分析" class="headerlink" title="Java内存分析"></a>Java内存分析</h2><p>java内存 堆：存放new的对象和数组<br>             可以被所有线程共享，不会存放别的对象的引用<br>         栈：存放基本数据类型(会包含这个基本类的具体数值)<br>             引用对象的变量(会存放这个对象在堆里面的具体地址)<br>         方法区：可以被所有线程共享<br>                 包含所有class和static变量</p><h2 id="Java面向对象编程oop"><a href="#Java面向对象编程oop" class="headerlink" title="Java面向对象编程oop"></a>Java面向对象编程oop</h2><p>面向过程编程 线性思维<br>面向对象编程 分类思维<br>本质：以类的方式组织代码，以对象来组织(封装)数据 抽象<br>三大特性；继承 封装 多态<br>this：指当前对象<br>类只包含属性和方法 是抽象的，使用的时候一定要示例化<br>使用new来创建对象 的时候除了灰分配空间，还会对创建好的对象 进行默认的初始化(调用类的构造方法)和类中构造器的调用</p><p>类中构造器也成构造方法，用来初始化值，是在进行创建对象的时候必须被调用的方法，构造方法有两个特点，和类名相同，没有返回类型也不能写void<br>类的构造方法会默认存在一个无参构造，即使类中什么也没写，如果一旦写了有参构造那么无参构造就一定要写出来</p><p>可以使用alt+insert快捷键<br>来生成构造</p><p>封装：属性私有 get&#x2F;set方法来操作数据  alt+insert快捷键来生成get&#x2F;set<br>        提高程序安全性，保护数据<br>        统一接口<br>        隐藏代码实现细节<br>继承： extends java只能单继承<br>ctrl+h 打开继承树<br>在java中只会有单继承<br>子类继承父类，会拥有父类所有的方法，无法继承私有的<br>supper代表父类对象的引用，也只能出现在子类之中，子类会默认存在一个supper()方在第一行也必须是第一个调用父类的构造方法，supper和this不能同时调用构造方法<br>supper和this的区别与注意点<br>代表的对象不同<br>    this：本身调用者这个对象<br>    supper：父类对象的引用<br>前提条件不同<br>    this：没有继承也可以使用<br>    supper：只有存在继承条件才可以死使用<br>构造方法不同<br>    this():本类的构造<br>    supper():父类的构造</p><p>方法的重写<br>    静态方法和被final修饰的不能重写<br>    父类的引用指向子类<br>    重写都是方法的重写和属性无关<br>    需要有继承关系<br>    是子类重写父类的方法执行子类的方法<br>    方法名字和参数列表必须一样。方法体不一样<br>    修饰符范围可以扩大但不能缩小<br>    抛出的异常范围可以缩小但不能扩大<br>为什么需要重写？<br>    1.父类的功能子类不一定需要<br>多态：同一方法可以根据对象的不同产生不同的行为，一个对象的实际类型是确定的(因为new)，但可以指向对象的引用的类型可以有很多，也是方法的多态，和属性无关<br>多态存在的条件：<br>    1.存在继承关系<br>    2.子类重写父类方法<br>    3.父类引用指向子类对象  Animal animal &#x3D; new Cat(); cat是继承animal的子类 Animal animal<br>    一、使用父类类型的引用指向子类的对象；<br>    二、该引用只能调用父类中定义的方法和变量；<br>    三、如果子类中重写了父类中的一个方法，那么在调用这个方法的时候，将会调用子类中的这个方法；(动态连接、动态调用)<br>个人总结：父类的引用根据new的子类对象不同而产生不同的行为<br>instanceof 可以判断两个类是否有联系</p><h2 id="Java-static，final详解"><a href="#Java-static，final详解" class="headerlink" title="Java static，final详解"></a>Java static，final详解</h2><p>static：静态的<br>    在java中静态属性是和类一起加载<br>    静态方法或者类的静态属性，是可以直接通过类名. 来使用的<br>    非静态方法就不能需要类的实例化<br>    被static修饰的成员变量和成员方法独立于该类的任何对象，也就是说他不依赖类的任何特殊实例，被类的所有实例所共享，只要这个类被加载了，java虚拟机能根据类名在运行时数据区的方法区内找到他们。<br>    静态变量(类变量)：静态变量被所有的对象共享，也就是说我们创建了 一个类的多个对象，但是这个类具有一个静态变量，那么这多个对象其实就是共享这一个静态变量，如果我们修改了这个静态变量的值，那么其他对象的静态变量值也会随之修改。<br>    非静态变量(实例变量)：如果我们创建了一个类的多个对象，那么每个对象都会有属于自己的非静态变量，当你修改一个对象的非静态变量的时候 不会引起其他对象的非静态变量值发生改变<br>    static修饰的方法 成员称作静态方法，静态方法的使用可以通过类名.方法名来进行调用，由于静态 方法在类加载的时候就已经存在，所以说静态方法并不依赖任何一个实例对象<br>final：被final修饰的变量是常量，值不可以改变<br>       被final修饰的方法不能被重写<br>       被final修饰的类不能够被继承</p><h2 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h2><p>abstract：被abstract修饰的类就为抽象类，方法为抽象方法<br>抽象类：不一定只含有抽象方法<br>        抽象类只能够继承，不能够被实例化<br>        子类继承抽象类就必须实现抽象类没有被实现的抽象方法<br>抽象方法：只有方法的定义没有方法的实现，只能存在于抽象类，有抽象方法此类必为抽象类<br>抽象方法：只有方法的定义没有方法的实现<br>思考：抽象类有没有构造器 有<br>抽象类是有构造器的</p><h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><p>interface：定义接口 相当于一种约束<br>接口只能定义抽象方法，所以接口都需要有一个实现类<br>让类实现接口就需要用到implemens关键字来实现接口<br>借口不能被实例化，也没有构造函数<br>实现接口的类，就必须实现接口中的抽象方法<br>抽象类和接口的区别<br>    1.抽象类除了不能够被实例化以外，其余和普通类没什么区别<br>    2.接口是完全抽象的，不存在抽象方法的实现，只能够定义抽象方法，也没有构造器<br>    3.一个子类只能继承一个抽象类，但是可以实现多个接口<br>    4.抽象类可以有构造方法，接口没有构造方法<br>    5.抽象类可以有普通成员变量，接口没有普通成员变量<br>    6.抽象类和接口都可以有静态成员变量，抽象类中静态成员变量的访问类型可以是任意的，而接口只能是 public static final</p><h2 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h2><h3 id="成员内部类"><a href="#成员内部类" class="headerlink" title="成员内部类"></a>成员内部类</h3><p>​一个类中写了另一个类。这个内部类作为外部类的成员，这个内部内可以获得外部类的私有变量和私有方法  </p><h3 id="局部内部类"><a href="#局部内部类" class="headerlink" title="局部内部类"></a>局部内部类</h3><p>​类中的方法里面包含一个类</p><h2 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h2><p>抛出异常throw:在方法内抛出  throws：抛出方法外<br>捕获异常<br>try{<br>    检测异常区域<br>}catch(什么样的异常){&#x2F;&#x2F;捕获异常<br>    捕获后怎么处理<br>}finally{<br>    异常善后工作<br>}<br>ctrl+alt+t快捷键用来对选中语句生成try-catch</p><h2 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h2><h3 id="JAVA内存模型-JMM"><a href="#JAVA内存模型-JMM" class="headerlink" title="JAVA内存模型(JMM)"></a>JAVA内存模型(JMM)</h3><p>java内存模型 描述了Java程序中各种变量(线程共享变量)的访问规则，以及在JVM中将变量存储到内存和从内存中读取出变量这样的底层细节。<br>可见性：一个线程对共享变量值的修改，能够及时地被其他线程看到。<br>共享变量：如果一个变量在多个线程的工作内存中都存在副本，那么这个变量就是这几个线程的共享变量。<br>乐观锁 与 悲观锁<br>CAS(Compare And Swap 比较并且替换)是乐观锁的一种实现方式，是一种轻量级锁，JUC 中很多工具类的实现就是基于 CAS 的。<br>CAS 是怎么实现线程安全的？<br>线程在读取数据时不进行加锁，在准备写回数据时，先去查询原值，操作的时候比较原值是否修改，若未被其他线程修改则写回，若已被修改，则重新执行读取流程。<br>他是乐观锁的一种实现，就是说认为数据总是不会被更改，我是乐观的仔，每次我都觉得你不会渣我，差不多是这个意思。<br>cas采用的是自旋锁(一直尝试，直到成功)的思想，是一种轻量级的锁机制。<br>悲观锁<br>悲观锁从宏观的角度讲就是，他是个渣男，你认为他每次都会渣你，所以你每次都提防着他<br>AQS：也就是队列同步器，这是实现 ReentrantLock 的基础。</p><h3 id="JAVA并发-理论基础"><a href="#JAVA并发-理论基础" class="headerlink" title="JAVA并发-理论基础"></a>JAVA并发-理论基础</h3><p>并发出现问题的根源 并发三要素:可见性，原子性，有序性<br>    可见性：cpu缓存引起<br>    定义：一个线程对共享变量的修改，另外一个线程能够立马看得到<br>    原子性：分时复用引起<br>    定义:即一个操作或者多个操作，要不全部执行并且在执行的过程中不会被任何因素所打断，要么就全都不执行<br>    有序性：重排序引起<br>    定义：即程序的执行顺序按照代码的先后顺序进行执行<br>在执行程序时为了提高性能，编译器和处理器常常会对指令做重排序。重排序分三种类型： </p><p>1、编译器优化的重排序。编译器在不改变单线程程序语义的前提下，可以重新安排语句的执行顺序。 </p><p>2、指令级并行的重排序。现代处理器采用了指令级并行技术(Instruction-Level Parallelism， ILP)来将多条指令重叠执行。如果不存在数据依赖性，处理器可以改变语句对应机器指令的执行顺序。 </p><p>3、内存系统的重排序。由于处理器使用缓存和读 &#x2F; 写缓冲区，这使得加载和存储操作看上去可能是在乱序执行。<br>原子性：一般来说 只有简单的赋值、读取 操作语句才有可能是原子操作 才能体现原子性 对于这种赋值来说还必须应该是将数字 赋值给某个变量，变量之间的相互赋值还不算是原子操作，为啥 因为 这涉及到两个步骤 ①他会先去读一个变量的值，然后再将这个变量的值赋值给另一个变量的值<br>我们由此可以看来 java内存模型只保证了基本读取和赋值是原子操作，如果要实现更大范围的原子操作就必须使用到java的关键字synchronized和Lock来实现</p><p>在我们java中 通常都会使用它到 synchronized 和 volatile  他们两个都是用在多线程的环境下。</p><h4 id="Volatile"><a href="#Volatile" class="headerlink" title="Volatile"></a>Volatile</h4><p>​volatile保证不同线程对共享变量操作的可见性，也就是说一个线程修改了volatile修饰的变量，当修改写回主内存时，另外一个线程立即看到最新的值。<br>具备两种特性 </p><ul><li><p>当我们改变了一个volatile，jvm会把其他线程对应的本地内存中的变量强制刷新，立即获取主内存中最新的值 ,从而来保证此<em><strong>变量对所有线程的可见性</strong></em></p></li><li><p><em><strong>防止指令重排序</strong></em>：重排序是指JVM的即时编译器和处理器为了优化程序性能而对指令序列进行重新排序的一种手段。</p><ul><li><p>这个时候就会有疑问</p><ol><li><p>是怎么保证可见性的？</p></li><li><p>为什么要保证可见性？</p></li><li><p>怎么防止指令重排序的？</p></li><li><p>为什么要防止指令重排序？</p><p>​可见性问题主要是指一个线程修改了共享变量值，而另一个线程却看不到。引起这种问题的主要原因在于每个线程拥有一个自己的高速缓存区（本地线程工作内存），如果不保证可见性的话，多个线程之间就会出现数据不一致的问题。而volatile是基于内存屏障来实现变量的内存可见性。在 volatile 修饰的共享变量进行写操作的时候，编译后会多出 lock 前缀的指令，lock 前缀的指令在多核处理器下会引发两件事情:</p><ol><li>将当前线程处理器缓存行的数据写回到系统内存也就是主内存中。</li><li>写回主内存的操作会使在其他 CPU 里缓存了该内存地址的数据无效。</li></ol><p>如果对声明了 volatile 的变量进行写操作，JVM 就会向处理器发送一条 lock 前缀的指令，将这个变量所在缓存行的数据写回到系统内存也就是主内存。</p><p>为了保证各个处理器的缓存是一致的，实现了缓存一致性协议(MESI)，每个处理器通过嗅探在总线上传播的数据来检查自己缓存的值是不是过期了，当处理器发现自己缓存行对应的内存地址被修改，就会将当前处理器的缓存行设置成无效状态，当处理器对这个数据进行修改操作的时候，会重新从系统内存中把数据读到处理器缓存里。</p><p>所有多核处理器下还会完成：当处理器发现本地缓存失效后，就会从内存中重读该变量数据，即可以获取当前最新值保证数据可见性。</p><p>而对于指令重排序也是如此，指令重排序后导致执行顺序出现问题，而Lock前缀：Lock不是一种内存屏障，但是它能完成类似全能型内存屏障的功能。为什么说Lock是一种伪类型的内存屏障，是因为内存屏障具有happen-before的效果，而Lock在一定程度上保证了先后执行的顺序，因此也叫做伪类型。比如，IO操作的指令，当指令不执行时，就具有了mfence的功能。</p><p>总而言之一个变量被volatile关键字修饰之后有两个作用：</p><p>（1）对于写操作：对变量更改完之后，要立刻写回到主存中。</p><p>（2）对于读操作：对变量读取的时候，要从主存中读，而不是缓存。</p><p>volatile 变量通过这样的机制就使得每个线程都能获得该变量的最新值来保证数据的可见性和有序性。</p></li></ol></li></ul></li></ul><p>使用场景：只能在有限的情形下使用volatile变量替代锁，要使volatile变量提供理想的线程安全，必须同时满足一下两个条件<br>    ①对变量的写操作不依赖于当前值。<br>    ②改变量没有包含在具有其他变量的不变市中。<br>    volatile 最适合 一个线程写 多个线程读的情况下。如果有多个线程并发写的操作<br>volatile 和 synchronized 的区别<br>    1、volatile 关键字是线程同步的轻量级实现，所以从性能这一方面来讲 volatile 比 synchronize要好，volatile只能修饰变量，而synchronized可以修饰方法、代码块。随着jdk版本的发布 synchronized的执行效率有很大的提升，在开发中使用synchronized的比率还是很大。<br>    2、多线程环境 访问volatile变量不会发生阻塞，而synchronized可能会发生阻塞<br>    3、volatile可以保证数据的可见性，但是不能保证原子性；而synchronize的可以保证原子性也可以保证可见性<br>    4、关键字volatile 解决的是变量在多个线程之间的可见性；synchronized关键字解决多个线程之间的访问公共资源的同步性</p><p>一个应用程序在运行时会有多个进程，而一个人进程又包含多个线程—-&gt;每个进程都会有自己的生命周期，所以每个线程也都会有自己的生命周期<br>一个进程在jvm中会有一个堆，而每一个线程都会有一个自己的栈和程序计数器，而这些线程栈会共享进程堆和方法区<br>优点：<br>    1.提高应用程序的响应<br>    2.提高计算机系统cpu的利用率<br>    3.改善程序结构<br>应用场景：<br>    1.程序需要同时执行两个或者多个任务<br>    2.程序需要实现一些需要等待的任务时，如用户输入，文件读写操作，网络操作，搜索等<br>    3.需要一些后台运行时<br>Thread类方法详解：<br>start方法：①启动当前线程 ②调用当前线程的run方法<br>run方法：通常需要重写此方法，内容就是需要此线程做的事<br>currentThread方法：静态方法，返回执行当前代码的线程<br>getname方法：获取当前线程的名字<br>setname方法：设置当前线程的名字<br>yield方法：释放当前cpu执行权<br>join方法：在线程a中调用线程b的join方法，此时线程a就进入阻塞状态，直到线程b完全执行完以后，线程a才结束阻塞状态<br>stop方法：已过时，强制结束线程<br>sleep方法：带参数毫秒，让当前线程”睡眠“，在指定的毫秒内，线程是阻塞状态<br>isalive方法：判断线程是否还存活<br>线程的优先级：<br>    10 5(默认) 1<br>    getpriority方法 获取线程优先级<br>    setpriority设置线程优先级<br>怎么实现多线程？<br>方法一：通过继承Thread类，重写run方法，用子类对象通过start方法启动线程<br>    1.创建一个继承Thread类的子类<br>    2.重写父类的run方法–&gt;run方法内容就是需要此线程做的事<br>    3.实例化子类对象，通过子类对象start方法来启动多线程<br>方法二：实现Runnable类接口，重写run方法。<br>    1.创建一个实现Runnable接口的实现类<br>    2.实现runnabl接口类中的run方法<br>    3.示例化一个实现类的对象<br>    4.将这个对象作为参数传递给thread类的构造方法中，创建thread类的对象<br>    5.还是通过这个thread类对象调用start方法<br>方法一与方法二比较：<br>开发中优先使用实现Runnable接口的方式来创建<br>原因：<br>    1.实现的方法没有单继承的局限性<br>    2.自然而然的解决多个线程共享数据的问题<br>    相同点：其实thread类也实现了Runnable接口<br>    1.都需要重写run()方法，将索要执行的逻辑写在run方法之中<br>    经典例题：消费者生产者问题<br>方法三：实现callable接口重写call方法并使用future来获取call方法的返回结果<br>    jdk5.0新增方式<br>    1.创建一个实现callable接口的实现类<br>    2.实现call方法，将需要此线程所做的操作内容写入此方法中，需要注意的是call方法是具有返回值的<br>    3.创建实现类对象<br>    4.将此实现类对象作为参数传入futuretask构造器之中，创建futuretask对象<br>    5.将futuretask对象又作为参数出入thread构造器之中，创建thread对象<br>    6.通过thread对象的start方法来启动线程<br>    7.就可以通过futuretask对象的get方法获取到call方法的返回值，也就是线程的返回值，这个时候可能会异常需要抛出。<br>    实现runable接口和实现callable接口都可以实现多线程<br>    而实现callable接口相比于实现runable接口的优点在于<br>    call方法有返回值，并且还可以抛出异常也支持泛型 run方法没有返回值<br>方法四：实现多线程池<br>    线程池；有多个线程组成的池子，提前创建多个线程，使用时直接获取，用完后返回，可以实现线程的重复利用<br>    有点：①减少创建新线程的时间，提高响应速度<br>          ②重复利用线程，避免资源浪费<br>          ③便于线程管理<br>        corepoolsize：核心池的大小<br>        maxnumpoolsize：最大线程数<br>        keepalivetime：线程存在时间<br>    ExecutorsService: 真正的线程池接口。常用的子类为ThreadPoolExecutors  通过这个子类的对象可以设置我们的线程池，使我们的线程池便于管理<br>Execuyors：线程池工厂类，用于创建线程池<br>    1.实例化创建指定数量的的线程池<br>    2.执行指定的线程的操作。需要提供实现Runnable接口或callable接口实现类的对象<br>    3.通过shoutdown方法关闭线程池<br>线程的生命周期：一般有五种状态<br>    创建，就绪，运行，阻塞，死亡<br>new<br>runnable<br>blocked<br>waitting<br>新建：当一个线程被new的时候就是新建<br>就绪：当线程调用start方法后就是进入就绪状态，此时还没有被CPU分配资源<br>运行：当线程获取到CPU执行权是就处于运行状态，当正在运行的线程失去CPU执行权或者被挂起时就又回到了就绪状态<br>阻塞：当正在运行的线程出现sleep，join，wait，等待同步锁，suspend的方法时，线程就会进入阻塞状态，阻塞状态结束的时候会回到就绪状态等待CPU执行<br>死亡：当正在运行的线程执行完run方法或者调用stoop方法或者出现异常没有解决的时候线程就会死亡，一个线程的最终状态也就是死亡</p><p>线程的同步：其实也就是为了解决线程的安全问题<br>同步的方法一：同步代码块<br>利用synchronized(同步监视器){<br>    &#x2F;&#x2F;这里就是需要被同步的代码  同步的代码可以理解为操作共享数据的代码，就是需要被同步的代码  共享数据就是多个线程操作的变量<br>}<br>    说明：同步监视器 俗称锁 任何一个类的对象都可以充当锁 所有的线程需要共用一把锁<br>synchronized<br>    优点：解决线程安全问题<br>    缺点：操作同步代码块的时候其实只允许一个线程运行，其他的线程则需要等待，相当于是一个单线程的过程效率低<br>同步的方法二：同步方法<br>    也是利用synchronized 将方法申明为同步方法<br>    也会涉及到同步监视器，只不过不会显示声明<br>    对于静态方法的监视器 默认为当前类本身<br>    对于非静态方法默认为 this 当前对象<br>死锁问题<br>    不同的线程分别占用对方需要的同步资源不放弃，都在等待对方放弃自己需要的同步资源，这样就形成了死锁问题<br>同步的方法三：lock锁接口<br>        先要实例化lock<br>        调用lock上锁<br>        就一定要调用unlock解锁调用<br>synchronized与lock锁的异同<br>    相同点：都可以解决线程安全问题<br>    不同点：synchronized在执行完同步代码块的内容时会自动释放lock锁<br>            lock需要我们手动上锁，和手动解锁<br>线程安全问题的解决方式有三种<br>        同步代码块<br>        同步方法<br>        lock锁接口<br>线程的通信<br>    wait():执行此方法就会使当前线程就进入阻塞状态，并释放同步监视器<br>    notify()：执行此方法就会唤醒被wait的一个线程，此时如果有多个线程被wait就会唤醒优先级比较高的线程 都是位于java.Object<br>    notifyall()：执行此方法就会唤醒所有被wait的线程 都是位于java.Object类。<br>这三种方法的使用必须是在同步方法或者同步代码块之中<br>这三种方法的调用者也不一样 同步代码块或者同步方法的对象也就是同步监视器<br>这三种方法都是定义在onject类之中<br>sleep方法和wait方法的异同<br>        相同点：都可以使线程进入阻塞状态<br>        不同点：申明的位置不同 sleep申明在threed类之中 wait申明在object之中<br>                调用要求不同 sleep在任何需要调用的地方都可以调用，wait只能在同步代码快之中调用<br>                是否释放同步监视器 如果两个方法都定义在同步代码快或者同步方法之中，sleep不会释放锁 wait会释放锁</p><h2 id="java常用类"><a href="#java常用类" class="headerlink" title="java常用类"></a>java常用类</h2><h3 id="字符串相关的类"><a href="#字符串相关的类" class="headerlink" title="字符串相关的类"></a>字符串相关的类</h3><p>String类及常用方法：<br>String是一个final类，不能够被继承也具有不可变性，字符内容实际上是存在一个字符数组之中<br>String实现了Serializable接口：表示字符串是支持序列化得<br>实现了Comparable接口:表示字符串是可以比较大小的<br>具有不可变性：也就是说在对字符串内容进行修改或者赋值是，都会在方法区字符串常量池之中重新赋值<br>通过字面量的方式赋值，不同于其他类的对象通过new，此时字符串是存放在方法区的字符串常量池之中<br>而且方法区的字符串常量池中是不允许存储相同内容的字符串<br>String的实例化方式<br>方式一：通过字面量方式<br>方式二：通过new+构造器的方式<br>面试题：String s &#x3D; new String(“abc”)创建了几个对象？<br>两个对象，一个堆里面的new构造器 一个方法区里面的abc<br>字符串调用interm方法，返回值就在方法区的字符串常量池之中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-title function_">length</span><span class="hljs-params">()</span>:返回字符串的长度值<br><span class="hljs-type">char</span> <span class="hljs-title function_">charAt</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span>:返回某索引处的字符<br><span class="hljs-type">boolean</span> <span class="hljs-title function_">isEmpty</span><span class="hljs-params">()</span>:判断字符串是否为空<br>String <span class="hljs-title function_">toLowercase</span><span class="hljs-params">()</span>:默认语言环境，将字符串中所有字符转换为小写<br>String <span class="hljs-title function_">toUppercase</span><span class="hljs-params">()</span>:默认语言环境，将字符串中所有字符转换为大写<br>String <span class="hljs-title function_">trim</span><span class="hljs-params">()</span>:返回字符串副本，忽略首部空白和尾部空白<br><span class="hljs-type">boolean</span> <span class="hljs-title function_">equals</span><span class="hljs-params">(object obj)</span>：比较字符串的内容是否相同<br><span class="hljs-type">boolean</span> <span class="hljs-title function_">equalsIgnoreCase</span><span class="hljs-params">(object obj)</span>：比较字符串的内容是否相同，会忽略大小写<br>String <span class="hljs-title function_">concat</span><span class="hljs-params">(String str)</span>:将指定字符串连接到此字符串的结尾 类似于+<br>nt <span class="hljs-title function_">compareTo</span><span class="hljs-params">(String anotherStr)</span>:比较两个字符串的大小<br>String <span class="hljs-title function_">substring</span><span class="hljs-params">(<span class="hljs-type">int</span> beginindex)</span>：截取字符串，返回索引之后的字符串<br>String <span class="hljs-title function_">substring</span><span class="hljs-params">(<span class="hljs-type">int</span> beginindex，<span class="hljs-type">int</span> endindex)</span>：截取字符串，返回索引开始到结束的中间的的字符串，需要注意的是不会包含结束的那个索引也就是左闭又开<br><span class="hljs-type">boolean</span> <span class="hljs-title function_">endswitch</span><span class="hljs-params">(String str)</span>：测试字符串是否为指定字符串样进行结尾的<br><span class="hljs-type">boolean</span> <span class="hljs-title function_">startswitch</span><span class="hljs-params">(String str)</span>：测试字符串是否为指定字符串样进行开头的<br><span class="hljs-type">boolean</span> <span class="hljs-title function_">startswitch</span><span class="hljs-params">(String str，<span class="hljs-type">int</span>)</span>：测试字符串在指定索引处是否为指定字符串样进行开头的<br><span class="hljs-type">boolean</span> <span class="hljs-title function_">contains</span><span class="hljs-params">(String str)</span>：判断字符串内是否包含指定字符串<br><span class="hljs-type">int</span> <span class="hljs-title function_">indexOf</span><span class="hljs-params">(String str)</span>：返回指定字符串在字符串中出现的索引位置<br><span class="hljs-type">int</span> <span class="hljs-title function_">indexOf</span><span class="hljs-params">(String str，<span class="hljs-type">int</span> index)</span>：返回指定字符串在指定索引后字符串中出现的索引位置<br><span class="hljs-type">int</span> <span class="hljs-title function_">lastindexOf</span><span class="hljs-params">(String str)</span>：返回指定字符串在字符串中出现的索引位置，从后往前找<br><span class="hljs-type">int</span> <span class="hljs-title function_">lastindexOf</span><span class="hljs-params">(String str，<span class="hljs-type">int</span> index)</span>：返回指定字符串在指定索引前字符串中出现的索引位置，从后往前找<br>注意：没找到都默认返回-<span class="hljs-number">1</span><br>替换：<br>String <span class="hljs-title function_">replace</span><span class="hljs-params">(String oldstr,String newstr)</span>:将字符串中旧串替换为新串<br>匹配：<br><span class="hljs-type">boolean</span> <span class="hljs-title function_">matches</span><span class="hljs-params">(String regex)</span>:告知此字符串是否符合给定的正则表达式<br>切片：<br>String[] sqlit(String regex):根据给定的正则表达式拆分字符串<br></code></pre></td></tr></table></figure><p>String类型与基本数据类型转换问题<br>    String–》基本类型：不能通过强转将字符串转换为基本类型，而应该调用基本类型的包装类的静态parseXXX(str)方法<br>    基本类型–》String：调用String重载的valueof(基本类型)方法 或者通过+拼接””字符串也可以<br>String类型与char[]字符数组转换问题<br>String–》char[]:调用String类的tocharArray()方法返回字符数组<br>char[]–》string:将字符数组作为参数传入String的构造器中，就可返回得到一个字符串<br>String类型与byte[]转换问题<br>String–&gt;byte[]:直接调用String的getbytes()<br>byte[]–&gt;string：将byte[]作为参数传入String的构造器中，就可返回得到一个字符串<br>Stringbuffer类：<br>是可变序列，线程也是安全的，效率低 这个时候问题来了 我们为什么要说StringBuffer 是线程安全的呢 因为StringBuffer每一个公开的方法都是被synchronized 关键字所修饰 只允许一个线程进行访问 这样的话就导致效率偏低</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java">StringBuffer <span class="hljs-title function_">append</span><span class="hljs-params">(XXX)</span>:字符串拼接<br>StringBuffer <span class="hljs-title function_">delete</span><span class="hljs-params">(<span class="hljs-type">int</span> startindex,<span class="hljs-type">int</span> endindex)</span>:删除[str,end)指定位置内容左闭又开<br>StringBuffer <span class="hljs-title function_">replace</span><span class="hljs-params">(<span class="hljs-type">int</span> str,<span class="hljs-type">int</span> end,String str)</span>:吧[str,end)的内容替换为str<br>StringBuffer <span class="hljs-title function_">insert</span><span class="hljs-params">(<span class="hljs-type">int</span> index,XXX)</span>:在指定位置插入XXX<br>StringBuffer <span class="hljs-title function_">reverse</span><span class="hljs-params">()</span>:把当前字符串逆转<br><span class="hljs-keyword">public</span> <span class="hljs-title function_">indexOf</span><span class="hljs-params">(String str)</span><br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">substring</span><span class="hljs-params">(<span class="hljs-type">int</span> start,<span class="hljs-type">int</span> end)</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">length</span><span class="hljs-params">()</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">char</span> <span class="hljs-title function_">charAt</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setcharAt</span><span class="hljs-params">(<span class="hljs-type">int</span> n,<span class="hljs-type">char</span> ch)</span>将索引处的字符替换为c<br></code></pre></td></tr></table></figure><p>Stringbuilder类：<br>    也是可变序列，线程是不安全的，但是效率高<br>    String 与StringBuffer与StringBuilder的异同<br>    String ①不可变的字符序列 内容和长度是不可以进行修改的，②并且重写了equals方法，③可以使用+来进行字符串的拼接<br>    Stringbuffer可变的字符序列 线程安全 效率低   ，<br>    Stringbuilder可变的字符序列 线程不安全 效率高<br>    相同点：都与字符串相关;底层都是通过char[]字符数组进行存储的</p><h3 id="时间相关的类"><a href="#时间相关的类" class="headerlink" title="时间相关的类"></a>时间相关的类</h3><p>jdk8之前得日期时间api<br>System静态方法 currentTimeMillis()用来返回当前时间与1970年1月1日0时0分0秒之间的毫秒差，称为时间戳<br>Date类<br>    掌握两个构造器的使用<br>    Date() 创建当前时间的date对象<br>    Data(时间戳) 创建指定毫秒数的date对象<br>    掌握两个方法的使用<br>    tostring()打印显示当前年月日时分秒<br>    getTime()获取时间戳<br>Calender类<br>    是一个抽象类不能被直接实例化<br>    通常创建GregorianCalendar()子类对象或者调用其静态方法getinstance()来进行实例化<br>常用方法<br>    get()<br>    set()<br>    add()<br>    gettime()<br>    settime()<br>SimpleDdateFormat类 对date类的格式化和解析<br>常用格式：<br>    Date date &#x3D; new Date();<br>    SimpleDateFormat simpleDateFormat &#x3D; new  SimpleDateFormat(“yyyy-MM-dd hh:mm:ss”); System.out.println(simpleDateFormat.format(date));<br>        格式化：将日期转化为字符串 通过format(Data date)<br>        解析：将字符串转化为日期 通过parse()  要求格式必须符合格式化的格式，否侧会抛异常<br>Date年偏移量1900 月偏移量1<br>jdk8新增日期时间api<br>以前的问题：有偏移性，线程也不是安全，<br>新版具有不可变性<br>实例化 调用now()方法获取当前<br>of()方法：设置指定年月日时分秒，没有偏移量<br>getXXX()获取需要的值<br>withXXX()设置需要的值<br>LocalDate本地日期<br>LocalTime本地时间<br>LocalDateTime本地日期时间<br>Instant 时间线上的一个点<br>DateTimeFormatter<br>通过ofpattern方法来进行实例化<br>类似于simpleDateformater用于格式化和解析</p><h3 id="Java比较器"><a href="#Java比较器" class="headerlink" title="Java比较器"></a>Java比较器</h3><p>Comparable接口 自然排序<br>    像String,包装类等实现了compareable接口，重写compareto(obj)方法 这个方法的内容就是比较两个对象的方法 默认从小到大<br>Comparator接口 订制排序按照参数来比较<br>    重写compare(object obj，object obj)(这两个接口都是比较对象的)<br>两者的区别：<br>    comparable接口的方式一旦确定，保证接口实现类的对象在任何位置都可以比较大小<br>    comparator接口属于临时性的比较。</p><h3 id="System类"><a href="#System类" class="headerlink" title="System类"></a>System类</h3><p>方法<br>    exit():退出系统</p><h3 id="Math类"><a href="#Math类" class="headerlink" title="Math类"></a>Math类</h3><p>提供一些常用的数学方法<br>    abs 绝对值<br>    random 随机数</p><h3 id="BigInteger和BigDecimal"><a href="#BigInteger和BigDecimal" class="headerlink" title="BigInteger和BigDecimal"></a>BigInteger和BigDecimal</h3><pre><code class="hljs">前者对数字长度后者对数字特别是浮点数精度可以做处理</code></pre><h2 id="枚举型-amp-注解"><a href="#枚举型-amp-注解" class="headerlink" title="枚举型&amp;注解"></a>枚举型&amp;注解</h2><p>枚举类<br>    类似数学枚举法 类的对象是有限个的并且是确定的<br>    当需要定义一组常量时，强烈建议使用enum<br>    如果枚举类中只有一个对象，就可以看成单例模式的一种实现方式<br>    枚举类的理解：类的对象只有有限个，确定的。我们称此类为枚举类<br>    当需要定义一组常量时，强烈建议使用枚举类<br>    如果枚举类中只有一个对象，则可以作为单例模式的实现方式(详细见构建者模式之单例模式)。<br>    枚举类的属性<br>    枚举类对象的属性不应允许被改动, 无setter()方法，所以应该使用 private final 修饰；<br>    枚举类的使用 private final 修饰的属性应该在构造器中为其赋值 ；<br>    枚举类的对象有限，所以构造器应该设置成私有，不允许外界添加；<br>    若枚举类显式的定义了带参数的构造器, 则在列出枚举值时也必须对应的传入参数。<br>    如何定义枚举类？<br>    方式一：jdk5.0之前 自定义枚举类<br>    ①申明自定义枚举类对象的属性：用private final修饰<br>    ②私有类的构造器，并给对象属性赋值<br>    ③提供当前类的多个枚举对象，public static final的<br>    ④其他诉求：获取枚举类对象的属性通过gat&#x2F;set方法<br>    ⑤其他诉求：提供toString方法，避免对象打印出地址值<br>    方式二：jdk5.0 通过enum关键字<br>    如何使用关键字enum来定义枚举类<br>    ①不需要class修饰类名而使用enum来修饰类名<br>    ②提供当前枚举类的对象，多个对象之间使用‘，’隔开末尾分号结束<br>    ③申明自定义枚举类对象的属性：用private final修饰<br>    ④私有类的构造器，并给对象属性赋值<br>    ⑤其他诉求：获取枚举类对象的属性通过gat&#x2F;set方法<br>    Enmu类的主要方法<br>    values()返回枚举类型的对象数组可以很方便的遍历所有枚举值<br>    valueof(String str)返回一个和str同名的枚举对象，如果没有找到，会报异常<br>    tostring()返回当前枚举类对象常量的名称<br>    实现接口的枚举类<br>    情况一：实现接口，在枚举类中实现接口抽象方法<br>    情况二：让枚举类对象分别实现抽象方法，个人感激啊有点类似于多态了<br>注解(Annotation)<br>注解概述<br>在jdk5.0新增 其实就是代码里的特殊标记<br>框架&#x3D;注解+反射+设计模式<br>注解前面都会有@符号<br>常见注解示例<br>示例一：文档注解<br>示例二：在编译时进行格式检查(jdk中内置的三个注解)<br>@Override 限定重写父类方法，该注解只能用于方法<br>@Deprecated 用于表示所修饰的元素已过时<br>@SuppressWarmings 抑制编译器警告<br>示例三：跟踪代码依赖性，实现替代配置文件功能<br>Servlet3.0提供注解，使得不需要在配置文件中进行servlet配置<br>spring框架中关于事务的管理<br>自定义注解 –参照SuppressWarmings注解定义<br>通过@interface 关键字定义<br>注解的成员变量无参方法的形式来申明<br>①注解声明为@interface<br>②内部定义成员通常value表示<br>③可以指定成员变量的默认值 通过default<br>④如果注解没有成员，那么就是一个标识，如果有就要给值<br>自定义注解必须配备上特定的信息处理流程(使用反射)才有意义<br>自定义注解通常都会指明两个元注解 retention target<br>jdk中的元注解<br>提供四种 元注解就是用于修饰注解的注解<br>retention指定注解的生命周期<br>target 用于限制注解可以修饰那些程序元素<br>利用反射获取注解信息<br>jdk8中注解新特性<br>可重复注解<br>类型注解<br>(都是jdk5.0新增内容</p><h2 id="java集合"><a href="#java集合" class="headerlink" title="java集合"></a>java集合</h2><h3 id="java集合框架概述"><a href="#java集合框架概述" class="headerlink" title="java集合框架概述"></a>java集合框架概述</h3><p>集合，数组都是对多个数据进行存储的 简称Java渣蛙容器  这个存储主要是指内存层面的，不涉及持久化<br>Array(数组)弊端：长度确定，类型确定 提供的方法很少，对于增删改查非常的不便 不能获取到实际元素个数 有序，可重复注解<br>分为两个大接口 Collection 单列数据存储一个一个的对象和Map 双列数据 用来存储一对一对的数据<br>ArrayList：元素有序 可重复 线程不安全<br>hashSet：元素无序 不可重复 线程不安全 可以存null<br>hashMap：双列集合 也就是一种键值对的集合，其中key是不可以重复的且无序，作为key对应的value只是可以重复的 并且需要注意的是key和value都是可以为空的 同样的是 他也是线程不安全的</p><h3 id="Collection接口方法"><a href="#Collection接口方法" class="headerlink" title="Collection接口方法"></a>Collection接口方法</h3><p>单列集合</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java">add(object obj):将元素obj添加到集合的方法 注意要求obj所在的类必须重写equals方法<br>size():获取集合元素个数<br>addall(Collection co):将co集合的所有元素添加到集合中<br>clear()：清空集合元素<br>isEmpty():判断集合是否有元素，这是一个返回值为布尔类型的函数<br>contains(object obj)：判断当前集合中是否包含obj 注意：我们在判断的时候会调用obj所在类的equals<br><span class="hljs-title function_">containsAll</span><span class="hljs-params">(Collection coll)</span>：判断集合coll中所有元素都存在与当前集合之中<br>remove(Object obj):从当前集合中移除元素obj 注意这个也默认要求obj所在类重写equals方法 会通过equals方法判断obj是否存在<br>removeAll(Collection coll):从当前集合中移除coll中所有的元素 相当于数学中的差集<br>retainALL(Collection coll)：获取当前集合和coll集合中相同的元素 相当于数学中交集<br>equals(object obj):判断当前集合与形参集合是否相同<br>hashcode()定义在object中 返回当前对象的哈希值。<br>toArray()：将集合转换为数组 扩展：<br>aslist()：将数组转换为集合 调用Arrays类的静态方法aslist()<br>iterator():返回迭代器iterator接口的示例，用于遍历Collection集合元素<br></code></pre></td></tr></table></figure><h3 id="lterator迭代器接口"><a href="#lterator迭代器接口" class="headerlink" title="lterator迭代器接口"></a>lterator迭代器接口</h3><p>一般都是通过集合对象调用iterator方法返回一个迭代器的示例<br>iterator迭代器有:<br>两个方法一个是 hasNext()判断是否还有下一个<br>next()指针下移读取下一个值<br>集合每次调用iterator方法时都会得到一个全新的迭代器对象<br>默认的指针都在集合第一个元素之前<br>迭代器内部定义了一个remove方法，可以在迭代器遍历的时候删除集合中的元素<br>jdk5.0新增特性增强for循环 for(集合元素类型 局部变量:集合对象)</p><h3 id="Collection子接口list"><a href="#Collection子接口list" class="headerlink" title="Collection子接口list"></a>Collection子接口list</h3><p>​元素有序 可重复 “动态”数组 底层长度为10<br>​通常使用list来替代数组<br>​常用的实现类有三个 ArrayList LinkedList vector<br>​三者的异同：都实现了list接口，存储特点也是相同的有序可重复</p><p>ArrayList 作为list主要实现类，线程是不安全的，效率高 底层使用的object[]存储.</p><p>vector 作为list的古老实现类 ，线程安全 效率低 底层使用的object[]存储</p><p>list集合除了继承Collection的方法外还提供了根据索引来操作集合的方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">void</span> <span class="hljs-title function_">add</span><span class="hljs-params">(<span class="hljs-type">int</span> index，object e)</span>：在index出插入元素e  (如果没有写index时 会默认在集合的末尾进行数据的添加)<br>boolen <span class="hljs-title function_">addAll</span><span class="hljs-params">(<span class="hljs-type">int</span> index,collection coll)</span>:在index处，插入集合coll的所有元素<br>Object <span class="hljs-title function_">get</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span>：获取指定集合中指定index下标处的值<br><span class="hljs-type">int</span> <span class="hljs-title function_">indexOf</span><span class="hljs-params">(Object obj)</span>:返回obj在当前集合中首次出现的位置<br><span class="hljs-type">int</span> <span class="hljs-title function_">lastindexof</span><span class="hljs-params">(object obj)</span>：返回obj在当前集合中末次出现的位置<br>object <span class="hljs-title function_">remove</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span>：移除指定index位置的元素，并返回此元素<br>object <span class="hljs-title function_">set</span><span class="hljs-params">(<span class="hljs-type">int</span> index，object ele)</span>：设置指定index位置的元素为ele<br>list <span class="hljs-title function_">sublist</span><span class="hljs-params">(<span class="hljs-type">int</span> fromindex，<span class="hljs-type">int</span> toindex)</span>：返回从fromindex到toindex的子集合<br>总结常用方法<br>增：add(obj)  这个方法可以有两个参数，第一个参数为添加元素的下标值(可以写也可以不写，不写的话默认为数组最后一个位置)，第二个元素为需要添加的元素值这个是必须要写的<br>删：remove(Object obj)/remove(<span class="hljs-type">int</span> index)  也可以是数组中存在的值也可以是数组中的下标，一般情况下都是索引-<br>改：set(index,newdata) 此方法将数组下标索引处的值修改为新的值 需要注意的是此处的操作实际上是一个修改的操作<br>查：get(index) 需要注意的是此方法执行时 参数一定是数组的下标值，获取数组集合某处下标处的位置<br>插：add(index,data) 向数组集合中插入数据 需要注意的是 方法有两个参数，第一个参数是插入数据在数组集合中的下标值可以写也可以不写，不写的话默认为数组最后一个位置)，第二个元素为需要添加的元素值这个是必须要写的<br>长度：size()  注意size是元素的个数并不是底层数组的长度<br></code></pre></td></tr></table></figure><p>遍历：①iterator迭代器<br>②增强for循环<br>③普通for循环</p><h3 id="Collection子接口set"><a href="#Collection子接口set" class="headerlink" title="Collection子接口set"></a>Collection子接口set</h3><p>​元素无序 不可重复 类似高中数学中的“集合” 底层其实是map<br>​三个主要实现类：Hashset，linkedhashset，treeaet<br>​Hashset：作为set借口的主要实现类，线程不安全可以存储null值  在底层也是通过数组+链表进行存储的(jdk7)<br>​linkedhashset：是hashset的一个子类，遍历内部是时可以按添加的循序进行遍历<br>​Treeset：可以按照添加对象的指定属性，进行排序</p><p>如何理解set接口的无序性和不可重复性<br>无序性：不是随机性，而是理解为以哈希值进行数组存储的的顺序<br>不可重复性：通过equals来判断，相同的元素只能添加一个</p><p>set借口没有新添加的方法，全部使用的是Collection的方法</p><p>要求：向set接口中添加数据，其所在得类一定要重写equals和hashcode方法</p><p>Treeset：在添加对象时只能添加相同类的对象，可以按照添加对象的指定属性，进行排序</p><h3 id="Map接口"><a href="#Map接口" class="headerlink" title="Map接口"></a>Map接口</h3><p>双列集合，用来存储一对一对的数据 类似高中数学中的函数<br>key 不能重复 无序(使用set存储key  key可能是一个对象如果是一个对象的话就要求可以所在得类必须重写equals和hashcode方法)<br>value 可以重复 一般使用colllection存储所有的value 如果value是对象 那么要求对象所在的类要重写equals方法</p><p>一个键值对就是key-value构成一个entry对象，map中的entry对象使用set存储<br>有三个常用的实现类分别为：Hashmap，linkedHashmap，hashTable<br>Hashmap：作为map主要的实现类，线程不安全的，效率高，能存储null的key和value  数组+链表+红黑树<br>linkedHashmap：作为hashmap的子类，保证在遍历map元素时，可以按照添加的循序进行遍历。原因：在原有的底层基础上，添加了一对指针，指向前一个和后一个，对于频繁的遍历，效率高于hashmap<br>Treemap：保证在key-value对进行排序，实现排序遍历，考虑对key进行自然排序和订制排序 底层使用红黑树实现<br>hashTable：作为古老的实现类，线程安全的，效率低，不能存储null的key和value<br>有一个子类 properties 使用来处理配置文件的 所有的key和value都是字符串的</p><p>HsahMap的底层实现原理？<br>在jdk8之前 使用的是数组+单向链表 在jdk8之后 使用的是 数组+链表+红黑树<br>jdk7版本<br>HashMap map &#x3D; new HashMap();<br>在实例化以后底层创建了一个16长度的一维数组entry[] table<br>map.put(key1,value1):执行添加操作<br>首先，调用key1所在类的hashcode方法计算哈希值，次哈希值经过某种算法后，得到在entry数组中分存放位置<br>如果存放位置为空，此时key1-value1添加成功 —-》情况1<br>如果存放位置不为空(意味着此位置存在一个或多个数据(以链表的形式存在))比较key1和已经存在的一个或多个数据的哈希值<br>如果key1的哈希值与存在的哈希值不相同，此时key1-value1添加成功 —-》情况2<br>如果key1的哈希值和已经存在的某一个数据(key2-value2)的哈希值相同，继续比较：调用key1所在类的equals(key2)方法<br>如果equals返回false：此时key1-value1添加成功 —-》情况3<br>如果equals返回true：使用value1替换value2结束，相当于如果有重复的key哈希值就对原先的值进行修改</p><p>补充：关于情况2和情况3：此时key1-value1和原来的数据以链表的方式存储<br>在不断的添加过程中，会涉及到扩容的问题，当超出临界值并且存放位置索引不为空时扩容 默认的扩容方式为扩容到原来的2倍，并将原来的数据复制过来</p><p>jsk8版本 相较于jdk7在底层实现的不同<br>1.在new HashMap()：底层不会创建一个长度为16的数组<br>2.底层的数组是node[]而非entry[]<br>3.首次调用put方法是，才会在底层创建一个16的数组<br>4.jdk7的底层结构为数据+链表 jdk8底层使用的是 数组+链表+红黑树<br>当数组的某一索引位置已经以链表的形式存在，存在的数据个数&gt;8 并且 整个数组的长度&gt;64时，<br>此时索引位置上的数据全部改为红黑树进行存储</p><p>hashmap的哈希函数是如何设计的？<br>将hashcode的高16位和低16位进行 位亦或操作 两个好处 ①尽可能降低哈希碰撞，越分散越好 ② 算法一定要尽可能高效 因为这是高频运算 追求高效 因此采用位运算</p><p>LinkedHsahMap的底层实现原理？</p><p>Map接口中常用的方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java">添加，删除，修改操作方法<br>Object <span class="hljs-title function_">put</span><span class="hljs-params">(Object key,Object value)</span> 将指定的key-value添加或修改到map对象之中<br><span class="hljs-keyword">void</span> <span class="hljs-title function_">putAll</span><span class="hljs-params">(Map m)</span> 将m中所有的key-value键值对存放到当前map之中<br>Object <span class="hljs-title function_">remove</span><span class="hljs-params">(Object key)</span> 将指定key的键值对移除，并返回指定key的value值<br><span class="hljs-keyword">void</span> <span class="hljs-title function_">clear</span><span class="hljs-params">()</span>:清空当前map中的所有元素<br><br>元素查询的操作<br>Object <span class="hljs-title function_">get</span><span class="hljs-params">(Object key)</span>: 获取指定key对应的value值<br><span class="hljs-type">boolean</span> <span class="hljs-title function_">containskey</span><span class="hljs-params">(Object key)</span>: 判断是否包含指定key<br><span class="hljs-type">boolean</span> <span class="hljs-title function_">containsvalue</span><span class="hljs-params">(Object value)</span>: 判断是否包含指定value值<br><span class="hljs-type">int</span> <span class="hljs-title function_">size</span><span class="hljs-params">()</span>:返回map中键值对的个数<br><span class="hljs-type">boolean</span> <span class="hljs-title function_">isEmpty</span><span class="hljs-params">()</span>:判断当前map是否为空<br><span class="hljs-type">boolean</span> <span class="hljs-title function_">equals</span><span class="hljs-params">(Object obj)</span>:判断当前map和参数对象obj是否相等<br><br>原始图的操作<br>set <span class="hljs-title function_">keyset</span><span class="hljs-params">()</span>:获取所有的key集合所构成的set集合<br>coll <span class="hljs-title function_">values</span><span class="hljs-params">()</span>:获取所有value值集合所构成的Collection集合<br>set <span class="hljs-title function_">entryset</span><span class="hljs-params">()</span>:返回所有key-value对所构成的set集合<br><br>总结常用的：<br>增：put(Object key,Object value)<br>删：remove(Object key)<br>改：put(Object key,Object value)<br>查：get(Object key)<br>长度：size()  注意size是元素的个数并不是底层数组的长度<br>遍历：set <span class="hljs-title function_">keyset</span><span class="hljs-params">()</span>  /   values()  /  entryset()<br></code></pre></td></tr></table></figure><p>Treemap：中key要求必须是同一类型的对象<br>因为要按照key进行排序，自然排序 订制排序</p><h3 id="Collections工具类"><a href="#Collections工具类" class="headerlink" title="Collections工具类"></a>Collections工具类</h3><p>面试题：Collection 和Collections的区别<br>Collection 是一个集合的接口 里面封装有list和set<br>Collections是一个用来操作list set map集合的工具类</p><p>是一个操作list set map等集合的工具类<br>常用方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java">reverse(list):反转list中元素的顺序<br>shuffle(list):对 list集合中的元素进行随机排序<br>sort(list):根据元素的自然顺序对指定的list集合元素按升序排序<br>sort(list,compareator):根据指定的compareator对指定的list集合排序<br>swap(list,<span class="hljs-type">int</span> i,<span class="hljs-type">int</span> j):将集合list的i处和j处进行交换<br><br>Object <span class="hljs-title function_">max</span><span class="hljs-params">(collection)</span>:根据集合的自然排序，返回给定集合中最大的值<br>Object <span class="hljs-title function_">max</span><span class="hljs-params">(collection，compareator)</span>:根据集合的订制排序，返回给定集合中最大的值<br>Object <span class="hljs-title function_">min</span><span class="hljs-params">(collection)</span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">frequency</span><span class="hljs-params">(collection,obj)</span>:返回在指定集合中元素obj出现的次数<br><span class="hljs-keyword">void</span> <span class="hljs-title function_">copy</span><span class="hljs-params">(list1,list2)</span>：将list2中的元素复制到list1之中<br></code></pre></td></tr></table></figure><p>也提供了多个线程安全的方法<br>synchronizedXXX(list):将list集合转化为对应的线程安全的集合</p><h2 id="java泛型"><a href="#java泛型" class="headerlink" title="java泛型"></a>java泛型</h2><p>1.为什么要有泛型<br>    泛型(generic) 可以理解为标签<br>    泛型就是在定义类的时候通过泛型来限制数据的类型，数据的类型是一定要与泛型是相同的数据类型<br>2.在集合中使用泛型<br>    在集合中不使用泛型，可能再添加数据的时候添加到了很多不一样的类型数据<br>    注意：泛型不能是基本类型，必须是包装类<br>    在集合中使用泛型进行类型检查保证数据安全<br>3.自定义泛型结构<br>    静态结构不能使用泛型<br>    异常类也不能申明为泛型<br>4.泛型在继承上的体现<br>    类a是类b的父类，所以他们就具有子父类之间的关系，但是G<a>和G<b>二者是不具备子父类的关系，二者是并列关系<br>    补充：类a是类b的父类，如果是这样a<G> 和 b<G>就具备了子父类之间的关系<br>5.通配符的使用<br>    通配符：？<br>    使用通配符之后 list&lt;?&gt; 不能向其添加数据，但是只允许添加null但是可以读取数据<br>6.泛型应用举例</p><h2 id="java-IO流"><a href="#java-IO流" class="headerlink" title="java IO流"></a>java IO流</h2><p>1.File类的使用<br>File类表示的就是文件和文件目录路径<br>1.一个File类的对象，代表一个文件或者一个文件目录<br>2.File类声明在java.io包下<br>3.在File类中并没有涉及到写入或者读取文件内容的操作  注意 文件的读写操作都是通过不同的六来进行操作 但是根据本人经验相关 通常使用一个流的时候都会将一个file对象作为参数传递给流构造器<br>4.后续File类的对象常会作为参数传递到流的构造器之中<br>File常用的构造器：<br>File(String pathname):以pathname为路径创建file对象，可以是绝对路径或者相对路径<br>File(String parent，String child)：以parent为父路径，child为子路径创建file对象<br>File(File parent，String child)：根据一个父file对象和子文件路径创建File对象<br>Files类的常用方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> String <span class="hljs-title function_">getabsolutepath</span><span class="hljs-params">()</span>:获取绝对路径<br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">getPath</span><span class="hljs-params">()</span>：获取路径<br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">getname</span><span class="hljs-params">()</span>：获取文件名称<br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">getparent</span><span class="hljs-params">()</span>：获取上层文件名称，或没有就为<span class="hljs-literal">null</span> <br><span class="hljs-keyword">public</span> <span class="hljs-type">long</span> <span class="hljs-title function_">length</span><span class="hljs-params">()</span>：获取文件长度(即字节数)，不能获取目录的长度 注意这个length其实就是文件的大小<br><span class="hljs-keyword">public</span> <span class="hljs-type">long</span> <span class="hljs-title function_">lastmodified</span><span class="hljs-params">()</span>：获取最后一次修改的时间，是一个时间戳毫秒值<br><br>用于文件目录<br><span class="hljs-keyword">public</span> String[] list():获取指定目录下的所有文件或者文件目录的名称数组<br><span class="hljs-keyword">public</span> File[] listFiles():获取指定目录下的所有文件或者文件目录的File数组<br>文件重命名<br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">renameTo</span><span class="hljs-params">(File dest)</span>:将文件重命名为指定的文件路径<br>比如：File1.renameTo(File2)为例<br>要想保证返回<span class="hljs-literal">true</span>，方法执行chengg，就必须保证file1是真是存在的，file2是不能存在的<br>用于判断<br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isDirectory</span><span class="hljs-params">()</span>:判断是否是文件目录<br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isFile</span><span class="hljs-params">()</span>:判断是否是文件<br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">exists</span><span class="hljs-params">()</span>:判断是否存在<br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">canread</span><span class="hljs-params">()</span>:判断是否可读<br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">canwrite</span><span class="hljs-params">()</span>:判断是否可写<br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isHidden</span><span class="hljs-params">()</span>:判断是否隐藏<br><br>创建硬盘中对应的文件或文件目录<br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">createNewFile</span><span class="hljs-params">()</span>:创建文件，若文件存在，则不创建，返回<span class="hljs-literal">false</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">mkdir</span><span class="hljs-params">()</span>:创建文件目录，如果此文件目录存在，就不创建了，如果此文件目录的上层文件不存在也不创建<br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">mkdirs</span><span class="hljs-params">()</span>:创建文件目录，如果上层文件不存在，一并创建<br><br>注意，如果创建文件没有写路径，那么默认在项目文件路径下<br><br>删除磁盘照片那个的文件或者文件目录<br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">delte</span><span class="hljs-params">()</span>：删除文件或者文件夹 删除目录时 文件 中不能还有文件夹和文件<br>注意：java中删除不走回收站<br></code></pre></td></tr></table></figure><p>2.IO流原理及流的分类<br>IO：input和output的缩写 处理设备之间的数据传输<br>在java中，数据的传输都是以流的形式进行传输</p><p>流的分类：按数据来分为字符流和字节流<br>按流向来分为输入流和输出流<br>按角色功能来分为 节点流和处理流</p><p>流的四个抽象基类  字节流       字符流<br>输入流        inputStream  Reader<br>输出流  outoutStream Writer</p><p>节点流      处理流<br>Fileinput<br>读取文件 从硬盘文件中读取数据到内存里<br>1.实例化file类的对象,指明要操作的文件，这文件必须存在不然会报错<br>2.提供具体的流 FillReader  注意  这里的意思就是 new一个流对象 但是需要注意的是要将file对象作为参数传递给流构造器<br>3.数据的读入<br>read()返回读入的一个字符，如果达到文件末尾，返回-1<br>read(char[] cbuf):返回每次读入cbuf数组中的字符个数，如果达到文件末尾返回-1<br>4.关闭数据流</p><p>写入文件 从内存中写出数据到硬盘的文件里<br>1.示例化file类的对象，指明要操作的文件 与读取不同的是 写入的文件如果不存在，会自动帮我们创建文件<br>2.提供具体的流对象 FileWriter<br>3.写入的操作  如果重复执行会讲原文件覆盖掉<br>Writer(Str,append) append默认为false 就是不会追加内容<br>4.关闭数据流</p><p>总结：对于文本文件需要使用字符流处理<br>对于非文本文件需要使用字节流来进行处理<br>3.节点流(文件流)<br>FileinputStream 字节输入节点流  用来读取文件<br>FileOutputStream 字节输出节点流<br>FileReader 字符输入节点流 用来输出文件<br>FileWriter 字符输出节点流<br>4.缓冲流<br>处理流的一种<br>BufferedInputStream  字节输入缓冲流<br>BufferedOutputStream 字节输出缓冲流<br>BufferedReader字符输入缓冲流<br>BufferedWriter字符输出缓冲流<br>注意在造流的时候一定要先实例化节点流，再将节点流对象出入缓冲流构造器实例化缓冲流的对象<br>作用：提高流的读取和写入的速度<br>原因：内部提供了一个缓冲区<br>处理流就是“套接”在已有的流的基础上<br>5.转换流 属于字符流<br>作用：提供了字节流和字符流之间的转换<br>InputStreamReader： 将字节的输入流转换为字符的输入流<br>OutputStreamWriter：将字符的输出流转换为字节的输出流<br>6.标准输入，输出流<br>System.in: 标准的输入流，默认从键盘输入<br>System.Out：标准的输出流，默认从控制台输出<br>7.打印流<br>8.数据流<br>9.对象流<br>对象序列化机制，将java对持久化得保存在硬盘文件中，或者通过网络传输出去<br>ObjectInputStream 反序列化 将文件中的数据转化为内存中的一个对象<br>ObjectoutputStream 序列化 将内存中的java对象保存在磁盘中或通过网络传输出去</p><p>一个类的对象需要满足一下条件<br>1.实现serializable接口<br>2.需要当前类提供一个id常量<br>3.还要保证该类的所有属性也是可以序列化的 ，默认java基本数据类型都是可以序列化的</p><p>注意：static和transient修饰的成员变量是不可以进行序列化的</p><p>10.随机存取文件流<br>RandomaccessFile:直接继承与object类 实现了datainput和dataouput接口 可读可写</p><h3 id="文件上传与下载"><a href="#文件上传与下载" class="headerlink" title="文件上传与下载"></a>文件上传与下载</h3><p>在java中通过io流便可实现对文件的上传与下载，无论是文件的上传与下载 都离不开对数据的读写操作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 按字节读取在保存</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment">int len;</span><br><span class="hljs-comment">byte[] bytes = new byte[1024];</span><br><span class="hljs-comment">while((len = byteArrayInputStream.read(bytes))!=-1)&#123;</span><br><span class="hljs-comment">       fileOutputStream.write(bytes,0,len);</span><br><span class="hljs-comment">&#125;</span><br><span class="hljs-comment">byteArrayInputStream.close();</span><br><span class="hljs-comment">fileOutputStream.close();</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">import</span> java.io.*;<br><span class="hljs-keyword">import</span> java.util.Arrays;<br> <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FileDemo</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String arg[])</span> &#123;<br>       <br>        <span class="hljs-keyword">try</span>&#123;<br>            FileInputStream fileInputStream=<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(<span class="hljs-string">&quot;filedemo.txt&quot;</span>);<br>            FileOutputStream fileOutputStream=<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(<span class="hljs-string">&quot;bytefile.txt&quot;</span>);<br>            <span class="hljs-type">int</span> len=<span class="hljs-number">0</span>;<br>            <span class="hljs-type">byte</span>[] bytes=<span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[fileInputStream.available()];<br>            <span class="hljs-keyword">while</span> ((len=fileInputStream.read(bytes))!=-<span class="hljs-number">1</span>)&#123;<br>                fileOutputStream.write(bytes,<span class="hljs-number">0</span>,len);<br>                fileOutputStream.flush();<br>            &#125;<br>        &#125;<span class="hljs-keyword">catch</span> (FileNotFoundException e)&#123;<br>            e.printStackTrace();<br>        &#125;<span class="hljs-keyword">catch</span> (IOException e)&#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-comment">// 按行读取在保存</span><br><span class="hljs-keyword">import</span> java.io.*;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FileDemo</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String arg[])</span> &#123;<br>        <span class="hljs-type">File</span> <span class="hljs-variable">file</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(<span class="hljs-string">&quot;filedemo.txt&quot;</span>);<span class="hljs-comment">//待读取文件,表示在项目根目录下</span><br>        String content;<br>        <span class="hljs-keyword">if</span>(file.exists())&#123;<br>            System.out.println(<span class="hljs-string">&quot;文件存在。不用创建&quot;</span>);<br>            <span class="hljs-keyword">try</span>&#123;<br>                String str;<br>                StringBuffer stringBuffer=<span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuffer</span>();<br><span class="hljs-comment">//                读取文件的内容</span><br>                FileInputStream fileInputStream=<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(file);<br>                InputStreamReader inputStreamReader=<span class="hljs-keyword">new</span> <span class="hljs-title class_">InputStreamReader</span>(fileInputStream,<span class="hljs-string">&quot;UTF-8&quot;</span>);<br>                BufferedReader bufferedReader=<span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedReader</span>(inputStreamReader);<br>                <span class="hljs-keyword">while</span> ((content=bufferedReader.readLine())!=<span class="hljs-literal">null</span>)&#123;<br>                    System.out.println(content);<br>                    stringBuffer.append(content);<br>                &#125;<br>                bufferedReader.close();<br>                inputStreamReader.close();<br>                fileInputStream.close();<br><span class="hljs-comment">//                向文件写入内容</span><br>                File newfile=<span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(<span class="hljs-string">&quot;newfile.txt&quot;</span>);<span class="hljs-comment">//待写入文件</span><br>                BufferedWriter bufferedWriter=<span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedWriter</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">OutputStreamWriter</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(newfile),<span class="hljs-string">&quot;UTF-8&quot;</span>));<span class="hljs-comment">//顺便练习下匿名类的使用           </span><br>                bufferedWriter.write(stringBuffer.toString());<br>                bufferedWriter.close();<br>                System.out.println(<span class="hljs-string">&quot;文件写入内容完成&quot;</span>);<br>            &#125;<span class="hljs-keyword">catch</span> (FileNotFoundException e)&#123;<br>                e.printStackTrace();<br>            &#125;<span class="hljs-keyword">catch</span> (UnsupportedEncodingException e)&#123;<br>                e.printStackTrace();<br>            &#125;<span class="hljs-keyword">catch</span> (IOException e)&#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>除此之外我们还可以借用第三方java类库（强烈推荐Hutool）文档：<a href="https://www.hutool.cn/docs/#/">https://www.hutool.cn/docs/#/</a>  Api：<a href="https://apidoc.gitee.com/dromara/hutool/">https://apidoc.gitee.com/dromara/hutool/</a><br>将字符串内容写入到指定位置：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">finalxml</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;hello world&quot;</span><br><span class="hljs-type">File</span> <span class="hljs-variable">file</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(<span class="hljs-string">&quot;C:\\Users\\Administrator\\Desktop\\002.ktr&quot;</span>);<br>        FileUtil.writeBytes(finalxml.getBytes(),file);<br></code></pre></td></tr></table></figure><h3 id="在web中实现文件下载功能"><a href="#在web中实现文件下载功能" class="headerlink" title="在web中实现文件下载功能"></a>在web中实现文件下载功能</h3><ol><li><p>可以通过在web页面中嵌入 url超级链接，标准的HTTP GET请求，形如：“<a href="http://www.wjj.cc/test.zip%E2%80%9D">http://www.wjj.cc/test.zip”</a> 的方式来下载。对于服务器端web根目录有一个test.zip的文件。不解释了，傻子都明白，看不明白就也没有必要去搞IT了。<br>说明：此种方法的弊端是完全暴露了文件test.zip的网站路径，而且动态性不够灵活。网上已经很多资料，不多说了。</p></li><li><p>通过服务器端将文件读取到内存以流的形式通过response返回给前端，然后前端在对流进行处理</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">      * <span class="hljs-doctag">@Description</span>: 导出Kettle转换</span><br><span class="hljs-comment">      * <span class="hljs-doctag">@Author</span>: wangcong</span><br><span class="hljs-comment">      * <span class="hljs-doctag">@Param</span>:</span><br><span class="hljs-comment">      * <span class="hljs-doctag">@Date</span>: 23-2-7 09:27</span><br><span class="hljs-comment">      * <span class="hljs-doctag">@return</span>:</span><br><span class="hljs-comment">    **/</span><br><span class="hljs-meta">@RequestMapping(&quot;exportTransformation&quot;)</span><br><span class="hljs-meta">@ResponseBody</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">exportTransformation</span><span class="hljs-params">(String id, HttpServletResponse response)</span>&#123;<br>    EnumMap&lt;ResultTrans, Object&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">EnumMap</span>&lt;ResultTrans, Object&gt;(ResultTrans.class);<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-type">TransMeta</span> <span class="hljs-variable">transMeta</span> <span class="hljs-operator">=</span> repository.loadTransformation(<span class="hljs-keyword">new</span> <span class="hljs-title class_">StringObjectId</span>(id), <span class="hljs-literal">null</span>);<br>        <span class="hljs-type">String</span> <span class="hljs-variable">herade</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;&lt;?xml version=\&quot;1.0\&quot; encoding=\&quot;UTF-8\&quot;?&gt;\n&quot;</span>;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">xml</span> <span class="hljs-operator">=</span> transMeta.getXML();<br>        <span class="hljs-type">String</span> <span class="hljs-variable">finalxml</span> <span class="hljs-operator">=</span> herade+xml;<br>        <span class="hljs-type">OutputStream</span> <span class="hljs-variable">outputStream</span> <span class="hljs-operator">=</span> response.getOutputStream();<br>        IOUtils.write(finalxml.getBytes(),outputStream);<br>    &#125; <span class="hljs-keyword">catch</span> (KettleException e) &#123;<br>        e.printStackTrace();s<br>    &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>        e.printStackTrace();<br>    &#125;<br>&#125;<br><br>前端vue<br>    <span class="hljs-title function_">downloadFile</span><span class="hljs-params">(row)</span> &#123;<br>    <span class="hljs-built_in">this</span>.$httpGet(<br>        <span class="hljs-string">&quot;downloadFile&quot;</span>,<br>        &#123; filePath: row.fileSavePath &#125;,<br>        &#123; responseType: <span class="hljs-string">&quot;blob&quot;</span> &#125;<br>    ).then(res =&gt; &#123;<br>        console.log(res);<br>        <span class="hljs-type">var</span> <span class="hljs-variable">blob</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Blob</span>([res]);<br>        <span class="hljs-type">var</span> <span class="hljs-variable">downloadElement</span> <span class="hljs-operator">=</span> document.createElement(<span class="hljs-string">&quot;a&quot;</span>);<br>        <span class="hljs-type">var</span> <span class="hljs-variable">href</span> <span class="hljs-operator">=</span> window.URL.createObjectURL(blob); <span class="hljs-comment">// 创建下载的链接</span><br>        downloadElement.href = href;<br>        downloadElement.download = row.fileName; <span class="hljs-comment">// 下载后文件名</span><br>        document.body.appendChild(downloadElement);<br>        downloadElement.click(); <span class="hljs-comment">// 点击下载</span><br>        document.body.removeChild(downloadElement); <span class="hljs-comment">// 下载完成移除元素</span><br>        window.URL.revokeObjectURL(href); <span class="hljs-comment">// 释放掉blob对象</span><br>    &#125;);<br>&#125;,<br></code></pre></td></tr></table></figure></li></ol><h2 id="java网络编程"><a href="#java网络编程" class="headerlink" title="java网络编程"></a>java网络编程</h2><p>1.网络编程概述<br>2.网络通信要素概述<br>3.通信要素1：IP和端口号<br>4.通信要素2：网络协议<br>5.TCP网络编程<br>    客户端<br>    1.创建socket的对象，指明服务器端的ip和端口号<br>    2.获取一个输出流，用于输出数据<br>    3.用流来写出数据的操作<br>    4.关闭流<br>    服务器端<br>    1.创建一个serversocket 指明自己的端口号<br>    2.调用对象的accept方法接受客户端的socket<br>    3.获取一个输入流<br>    4.通过输入流读数据<br>6.UDP网络编程<br>    客户端<br>    1.创建Datagramsocket类<br>    2.<br>7.URL编程<br>    url：统一资源定位符</p><h2 id="java反射机制"><a href="#java反射机制" class="headerlink" title="java反射机制"></a>java反射机制</h2><p>JAVA的反射机制主要作用是用来访问对象的属性、方法等等<br>1.关于反射机制的概述 反射的特征：动态性<br>    主要使用的API<br>        java.lang.class:代表一个类<br>        java.lang.reflect.method：代表类的方法<br>        java.lang.reflect.Field：代表类的成员变量<br>        java.lang.reflect.constructor：代表类的构造器<br>2.理解class类并获取class实例<br>    1.调用运行时类的属性：.class<br>        Class class1 &#x3D; Person.class;<br>    2.通过运行时类的对象调用getClass()<br>        Person p1 &#x3D; new Persoon();<br>        Class class1 &#x3D; p1.getClass();<br>    3.调用Class的静态方法forName();<br>        Class class1 &#x3D; Class.forName(“类的全包名”);<br>3.类的加载和classloader的理解<br>    使用类加载器读取配置文件<br>        Properties pros &#x3D; new Prooerties();<br>4.创建运行时类的对象<br>    Class<Person> clazz &#x3D; Person.class;<br>    Person obj &#x3D; clazz.newInstance();<br>    说明：newInstance():调用此方法，创建对应的运行时类的对象。内部调用了运行是类的空参的构造器。<br>          要想此方法正常的创建运行时类的对象，要求：<br>          1.运行时类必须提供空参的构造器<br>          2.空参的构造器的访问权限得够。通常，设置为public。<br>          在javabean中要求提供一个public的空参构造器。原因：<br>          1.便于通过反射，创建运行时类的对象<br>          2.便于子类继承此运行时类时，默认调用supper(),保证父类此构造器<br>5.获取运行时类的完整结构<br>6.调用运行时类的指定结构<br>7.反射的应用：动态代理<br>    动态代理：<br>        1、什么是动态代理？<br>            使用jdk的反射机制，创建对象的能力，创建的是代理类的对象，而不用你创建类文件，不用写java源文件<br>            动态：在程序运行时。调用jdk提供的方法动态创建代理类的对象<br>            注意：jdk动态代理 要求目标类必须实现接口，没有接口的话就需要使用cglib动态代理<br>        2、知道动态代理能做什么？<br>            在不改变目标类的功能方法前提下，在代理类中增强自己的功能代码。<br>            在实际程序开发中的意思<br>                比如 你所在的项目中，有一个功能是其他人已经写好的 你可以使用<br>                GoNong.class;   GoNong go &#x3D; new GoNong(); go.方法()<br>                你发现这个功能，现在还缺点意思，不能完全满足项目的需要，我们需要在go.方法()执行后，需要自己再增加代码<br>                用代理实现go.方法()调用时，增加自己的代码，而不用去修改原GoNong文件<br>    在静态代理中目标类很多的时候，可以使用动态代理，避免静态代理的缺点<br>    在动态代理中即使目标类很多 1)代理类的数量可以很少 2)当你修改了接口中的方法是不会影响到代理类<br>    通常我们的代理类主要完成两个功能：1)对目标类就是被代理类的方法的调用 2)在不改变原来代码的基础上实现新功能的增强<br>    动态代理是指代理类对象在程序运行是由我们的jvm动态生成的，动态代理是不需要定义代理类的.java源文件的<br>    动态代理其实jdk运行期间，动态创建class文件并加载的jvm<br>    动态代理常见的实现方式有两种 ①jdk动态代理 ②cglib动态代理<br>    依赖注入的原理就是动态代理</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs text">jdk动态代理：<br>jdk动态代理是基于java的反射机制实现的，使用jdk中的接口和类实现代理对象的动态创建。<br>jdk动态代理是要求我们的目标对象(被代理类)必须实现接口，这是java设计上的硬性要求<br>从jdk1.3以来，java语言通过java.lang.reflect包提供三个类来实现动态代理 Proxy、Method、InvocationHander(InvocationHander接口叫做调用处理器，负责调用目标类的方法，并增强功能，通过代理对象调用接口中的方法，会把方法的调用分配给调用处理器的实现类也就是invocationhander接口的实现类，会自动执行类中的invoke方法)，我们需要做的就是在invoke中调用目标类的方法，并进行增强。<br>cglib代理：<br>cglib是一个开源项目，是一个强大的，高性能的，高质量的code生成类库，它可以在项目运行期间扩展java类与实现java接口，它广泛的被许多AOP(面向切面编程)框架使用，例如SpringAOP.<br>使用JDK的Proxy实现代理，要求目标类与代理类实现相同的接口，若目标类不存在实现的接口，那么就无法使用这种方式实现动态代理。<br>对于无接口的类，要为其创建动态代理，就要使用cglib来实现cglib的原理是生成目标类的子类，而子类都是增强过的，这些子类其实就是不同的代理类，子类对象就是代理对象。所以使用cglib实现动态代理 要求我们的目标类是要能够被继承的 即目标类不是被final所修饰的类,调用的方法也是不能被final修饰的<br>cglib的要求是比较宽松的，只要能继承就行。经常被使用在框架中，例如spring，hibernate等，并且我们的cglib的代理效率是要高于我们的jdk的，<br>在我们真实的项目当中是很少使用到jdk来实现动态代理的 <br></code></pre></td></tr></table></figure><p>JDK实现动态代理：<br>        1. 反射，Method类，表示方法，类中的某个方法，通过Method可以执行某个方法。<br>        2. jdk动态代理的实现<br>            反射包 java.lang.refrct 里面有三个东西 invocationhander、Method、Proxy<br>            1)invocationHander接口(调用处理器)：就一个方法 invoke(Object proxy,Method method,Object[] args)<br>                invoke()：表示代理对象要执行的功能代码，我们的代理类要完成的功能就写在这个方法之中 ①调用目标方法执行目标方法的功能 ②功能增强，在目标方法调用时增加功能<br>                方法原型<br>                参数：Object proxy jdk创建的代理对象无需赋值<br>                      Method method 目标类中的方法，jdk提供method对象的<br>                      Object[] args 目标类中方法的参数，jdk提供的<br>                public Object invoke(Object proxy,Method method,Object[] args)<br>                invocationHander接口：表示你的代理要干什么<br>                怎么用：①创建类实现接口invocationHander<br>                        ②重写invoke方法，把原来静态代理类要完成的功能写在这<br>            2)Method类:表示方法的，确切的说表示目标类中的方法<br>                作用：通过method可以执行某个目标类的方法 method.invoke(目标对象，方法参数)<br>            3)Proxy类：核心的对象，创建代理对象。之前创建对象都是new类的构造方法，现在我们使用proxy类的方法代替<br>                方法：静态方法newProxyInstance() 作用是创建代理对象 等同于new一个代理类对象<br>                参数：<br>                1、ClassLoader loader: 类加载器 负责像内存中加载对象的，使用反射获取对象的classloader 固定写法<br>                2、Class&lt;?&gt; interface: 接口 目标对象实现的接口，也是通过反射获取的 固定写法<br>                3、InvocationHander h: 我们自己写的代理类要完成的功能<br>                返回值：就是动态创建的代理对象<br>    实现步骤<br>        1、创建接口，定义目标类要完成的功能。<br>        2、创建目标类实现接口<br>        3、创建InvocationHander接口的实现类，在invoke方法中完成代理对象需要完成的功能 ①调用目标方法 ②增强功能<br>        4、使用proxy类的静态方法，创建代理对象，并把返回值转为接口类型。</p><h2 id="java-JDBC"><a href="#java-JDBC" class="headerlink" title="java  JDBC"></a>java  JDBC</h2><p>1.加载数据库驱动<br>    Class.forName(“com.mysql.jdbc.Driver”);<br>2.通过Drivermanager的getConnection方法获取数据库连接对象<br>    Connection conn &#x3D; DriverManager.getConnection(“jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;jdbc”,”root”,”123456”);<br>3.通过数据库连接对象获取statement对象<br>    Statement statement &#x3D; conn.createStatement();<br>4.通过statement对象执行sql语句,并通过resultset保存返回结果<br>     ResultSet resultSet &#x3D; statement.executeQuery(“select * from tb_user”);<br>5.通过resultset对象操作结果集<br>    这里我们通常会将resultset的结果集转为list<Map></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//ResultSet 转List&lt;Map&gt;</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> List&lt;Map&lt;String, Object&gt;&gt; <span class="hljs-title function_">toListMap</span><span class="hljs-params">(ResultSet ret)</span> <span class="hljs-keyword">throws</span> SQLException&#123;<br>        List&lt;Map&lt;String, Object&gt;&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>();<br>        <span class="hljs-type">ResultSetMetaData</span> <span class="hljs-variable">meta</span> <span class="hljs-operator">=</span> ret.getMetaData();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">cot</span> <span class="hljs-operator">=</span> meta.getColumnCount();<br>        <span class="hljs-keyword">while</span>(ret.next()) &#123;<br>            Map&lt;String, Object&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>();<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; cot; i++) &#123;<br>                map.put(meta.getColumnName(i + <span class="hljs-number">1</span>), ret.getObject(i + <span class="hljs-number">1</span>));<br>            &#125;<br>            list.add(map);<br>        &#125;<br>        <span class="hljs-keyword">return</span> list;<br>    &#125;<br></code></pre></td></tr></table></figure><p>在我们的mybatis中 是如何批量插入或者更新数据的呢？<br>    一般我们通常会在XML文件中使用mybatis的<foreach>标签循环遍历<br>    在我们的mybatis中我们的foreach标签经常被使用到遍历集合，构建in条件语句和批量删除</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> product_ <br>    <span class="hljs-keyword">WHERE</span> ID <span class="hljs-keyword">in</span><br>            <span class="hljs-operator">&lt;</span>foreach item<span class="hljs-operator">=</span>&quot;item&quot; index<span class="hljs-operator">=</span>&quot;index&quot; collection<span class="hljs-operator">=</span>&quot;list&quot;<br>                <span class="hljs-keyword">open</span><span class="hljs-operator">=</span>&quot;(&quot; separator<span class="hljs-operator">=</span>&quot;,&quot; <span class="hljs-keyword">close</span><span class="hljs-operator">=</span>&quot;)&quot;<span class="hljs-operator">&gt;</span><br>                         #&#123;item&#125;<br>            <span class="hljs-operator">&lt;</span><span class="hljs-operator">/</span>foreach<span class="hljs-operator">&gt;</span><br></code></pre></td></tr></table></figure><p>foreach 标签主要有以下属性，说明如下。<br>item：表示集合中每一个元素进行迭代时的别名。<br>index：指定一个名字，表示在迭代过程中每次迭代到的位置。<br>open：表示该语句以什么开始(既然是 in 条件语句，所以必然以(开始)。<br>separator：表示在每次进行迭代之间以什么符号作为分隔符(既然是 in 条件语句，所以必然以,作为分隔符)。<br>close：表示该语句以什么结束(既然是 in 条件语句，所以必然以)开始)<br>使用 foreach 标签时，最关键、最容易出错的是 collection 属性，该属性是必选的，但在不同情况下该属性的值是不一样的，主要有以下 3 种情况：<br>如果传入的是单参数且参数类型是一个 List，collection 属性值为 list。<br>如果传入的是单参数且参数类型是一个 array 数组，collection 的属性值为 array。<br>如果传入的参数是多个，需要把它们封装成一个 Map，当然单参数也可以封装成 Map。Map 的 key 是参数名，collection 属性值是传入的 List 或 array 对象在自己封装的 Map 中的 key。</p><p>浅说一下mybatis的缓存</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs text">一级缓存：基于PerpetualCache的HashMap本地缓存，其存储作用域为Session，当我们的session flush或者close之后，该session中的所有Cache就将清空，默认打开一级缓存<br>二级缓存：与一级缓存及其机制相同，默认也是采用PerpetualCache，HashMap存储，不同在于其存储作用域为Mapper(namespace)，并且可以自定义存储源，如Ehcache。默认不打开二级缓存，要想开启二级缓存，要开启二级缓存，使用二级缓存属性类需要实现Serializable序列化接口(可用来保存对象的状态)，可在它的映射文件中配置；<br><br></code></pre></td></tr></table></figure><p>Mybatis缓存机制：<a href="https://blog.csdn.net/qq_44286009/article/details/125198442">https://blog.csdn.net/qq_44286009/article/details/125198442</a></p><h2 id="java执行过程"><a href="#java执行过程" class="headerlink" title="java执行过程"></a>java执行过程</h2><p>java执行过程通常来说 有两个关键步骤 编译 解释执行<br>java类在被加载到虚拟机中是有七个 生命周期<br>.java文件其实就是我们程序员所书写的java源码<br>.class文件 是我们源码经java虚拟机编译后生成的字节码文件</p><p>双亲委托模型的工作过程是：如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，<br>而是把这个请求委托给父类加载器去完成，每一个层次的类加载器都是如此，因此所有的加载请求最终都应该传送到顶层的启动类加载器中，只有当父类加载器反馈自己无法完成这个加载请求(它的搜索范围中没有找到所需要加载的类)时，子加载器才会尝试自己去加载。<br>使用双亲委托机制的好处是：能够有效确保一个类的全局唯一性，当程序中出现多个限定名相同的类时，类加载器在执行加载时，始终只会加载其中的某一个类。<br>注意：所谓限定名其实就是 含包文件路径类名称 全限定名&#x3D; 包名+类名</p><h2 id="JDK8-新特性"><a href="#JDK8-新特性" class="headerlink" title="JDK8 新特性"></a>JDK8 新特性</h2><h3 id="Lambda表达式"><a href="#Lambda表达式" class="headerlink" title="Lambda表达式"></a>Lambda表达式</h3><p>​其实偶然细想一下java8 有两个新特性 很像我们的es6的语法 就想我们的这个lambda表达式 像不像es6的箭头函数 你品 你细品<br>​举例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java">(o1，o2)-&gt; Integer.compare(o1,o2)<br>    格式：<br>    -&gt; : Lambda操作符 或者叫做 剪头操作符<br>        -&gt;左边 ：lambda形参列表 (其实就是接口中抽象方法的形参列表)<br>       -&gt;右边 ：Lambda体(其实就是重写的抽象方法的方法体)<br><span class="hljs-comment">//lambda表达式的使用(分为6种情况)</span><br><span class="hljs-comment">//语法格式一：无参，无返回值</span><br><span class="hljs-type">Runnable</span> <span class="hljs-variable">r1</span> <span class="hljs-operator">=</span> ()-&gt;&#123;System.out.println(<span class="hljs-string">&quot;hello world&quot;</span>);&#125;;<br><span class="hljs-comment">//语法格式二：lambda需要一个参数，但是没有返回值</span><br>Consumer&lt;String&gt; con = (String str)-&gt;&#123;System.out.println(str);&#125;;<br><span class="hljs-comment">//语法格式三：数据类型可以省略，因为可由编译器推断得出 称为 类型推断</span><br>Consumer&lt;Stting&gt; str = (str)-&gt;&#123;System.out.println(str);&#125;<br></code></pre></td></tr></table></figure><h3 id="Stream流"><a href="#Stream流" class="headerlink" title="Stream流"></a>Stream流</h3><p>​首先明确一点stream流并不是一种用来存储数据的一种数据结构，而是一种处理数据的处理方式。更加侧重于对源数据计算能力的封装，并且支持序列和并行两种操作方式。 序列？ 并行？</p><p>​stream流是从支持数据处理操作的源中生成的元素序列，这里源，可以是数组、集合、文件、函数。生成的这种元素序列我们就称之为流。需要注意的是流不是集合元素，它不是数据结构并不保存数据，流存在的主要目的便是用于计算处理数据。Stream流是对集合对象Collection功能的增强、与lambda表达式结合，可以提高编程效率，间接性与程序可读性</p><p><strong>特点</strong></p><ol><li>代码简洁：函数式编程写出的代码简洁意图明显，主要是从此告别for循环</li><li>多核友好：java函数式编程使得编写并行程序如此简单就是调用一下方法</li></ol><p><strong>流程</strong></p><pre><code class="hljs">1. 将集合转为Stream流（或者换句话来讲就是创建流） 2. 操作Stream流（操作流可以基本上分为两个过程：中间操作、终端操作）</code></pre><p>简要概述：Stream流在管道中经过中间操作的处理，最终由终端操作得到前面的处理结果</p><h4 id="流的生成方式（如何创建流）"><a href="#流的生成方式（如何创建流）" class="headerlink" title="流的生成方式（如何创建流）"></a>流的生成方式（如何创建流）</h4><h5 id="1-Stream创建"><a href="#1-Stream创建" class="headerlink" title="1.Stream创建"></a>1.Stream创建</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">Stream&lt;Integer&gt; stream1 = Stream.of(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>);<br></code></pre></td></tr></table></figure><h5 id="2-Collection集合创建（平时用的最多的一种）"><a href="#2-Collection集合创建（平时用的最多的一种）" class="headerlink" title="2.Collection集合创建（平时用的最多的一种）"></a>2.Collection集合创建（平时用的最多的一种）</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;Integer&gt; integerList = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        integerList.add(<span class="hljs-number">1</span>);<br>        integerList.add(<span class="hljs-number">2</span>);<br>        integerList.add(<span class="hljs-number">3</span>);<br>        integerList.add(<span class="hljs-number">4</span>);<br>        integerList.add(<span class="hljs-number">5</span>);<br>        Stream&lt;Integer&gt; listStream = integerList.stream();<br></code></pre></td></tr></table></figure><h5 id="3-Array数组创建"><a href="#3-Array数组创建" class="headerlink" title="3.Array数组创建"></a>3.Array数组创建</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span>[] intArr = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;;<br>        <span class="hljs-type">IntStream</span> <span class="hljs-variable">arrayStream</span> <span class="hljs-operator">=</span> Arrays.stream(intArr);<br></code></pre></td></tr></table></figure><p>通过Arrays数组工具类提供的<code>strtam(arr)</code>静态方法生成流，并且该方法生成的流是数值流(在这里就是 IntStream)而不是流，需要注意的是，使用数值流可以避免在计算过程中的拆线与装箱，提高性能，并且Stream API提供了<code>mapToInt</code>，<code>mapToDouble</code>，<code>mapToLong</code>三种方式将Stream流转换成对应的数值流，同时提供了<code>boxed</code>方法将数值流转换为对象流</p><h5 id="4-文件创建"><a href="#4-文件创建" class="headerlink" title="4.文件创建"></a>4.文件创建</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">try</span> &#123;<br>            Stream&lt;String&gt; fileStream = Files.lines(Paths.get(<span class="hljs-string">&quot;data.txt&quot;</span>), Charset.defaultCharset());<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br></code></pre></td></tr></table></figure><p>通过files工具类提供的静态方法<code>line</code>,并且得到的每个流是给定文件中的一行</p><h5 id="5-函数创建"><a href="#5-函数创建" class="headerlink" title="5.函数创建"></a>5.函数创建</h5><p><strong>iterator</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">Stream&lt;Integer&gt; iterateStream = Stream.iterate(<span class="hljs-number">0</span>, n -&gt; n + <span class="hljs-number">2</span>).limit(<span class="hljs-number">5</span>);<br></code></pre></td></tr></table></figure><p>通过Stream类的<code>iterate</code>方法创建流，接收两个参数，第一个参数为初始化值，第二个参数为进行的函数逻辑操作，因为iterate生成的流为无限流，通过limit方法对流进行截断，在这里只生成五个偶数</p><p> <strong>generator</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">Stream&lt;Double&gt; generateStream = Stream.generate(Math::random).limit(<span class="hljs-number">5</span>);<br></code></pre></td></tr></table></figure><p>generate方法接受一个参数，方法参数类型为Supplier ，由它为流提供值。generate生成的流也是无限流，因此通过limit对流进行了截断 supplier 是什么意思</p><h4 id="流的操作符"><a href="#流的操作符" class="headerlink" title="流的操作符"></a>流的操作符</h4><p>​流的操作符类型主要分为两种：<strong>中间操作符</strong>、<strong>终端操作符</strong></p><h5 id="中间操作符"><a href="#中间操作符" class="headerlink" title="中间操作符"></a>中间操作符</h5><p>​通常对于Stream的中间操作通常都是对于 源 的查询，并且是懒惰式的设计，对于源数据的计算只有在被需要的是</p><h5 id="终端操作符"><a href="#终端操作符" class="headerlink" title="终端操作符"></a>终端操作符</h5><p>参考博客：<a href="https://blog.csdn.net/MinggeQingchun/article/details/123184273">https://blog.csdn.net/MinggeQingchun/article/details/123184273</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Hexo个人博客搭建</title>
    <link href="/2022/07/20/Hexo%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"/>
    <url>/2022/07/20/Hexo%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/</url>
    
    <content type="html"><![CDATA[<h1 id="记录Hexo个人博客搭建"><a href="#记录Hexo个人博客搭建" class="headerlink" title="记录Hexo个人博客搭建"></a>记录Hexo个人博客搭建</h1><h2 id="搭建具体参考杰哥博客"><a href="#搭建具体参考杰哥博客" class="headerlink" title="搭建具体参考杰哥博客"></a>搭建具体参考杰哥博客</h2><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs llvm"><span class="hljs-symbol">https:</span>//yangdijie.github.io/<span class="hljs-number">2022</span>/<span class="hljs-number">02</span>/<span class="hljs-number">02</span>/<span class="hljs-number">2022</span><span class="hljs-variable">%E5</span><span class="hljs-variable">%B9</span><span class="hljs-variable">%B42</span><span class="hljs-variable">%E6</span><span class="hljs-variable">%9</span>C<span class="hljs-variable">%882</span><span class="hljs-variable">%E6</span><span class="hljs-variable">%97</span><span class="hljs-variable">%A5-hexo</span><span class="hljs-variable">%E6</span><span class="hljs-variable">%90</span><span class="hljs-variable">%AD</span><span class="hljs-variable">%E5</span><span class="hljs-variable">%BB</span><span class="hljs-variable">%BA</span><span class="hljs-variable">%E5</span><span class="hljs-variable">%8</span>D<span class="hljs-variable">%9</span>A<span class="hljs-variable">%E5</span><span class="hljs-variable">%AE</span><span class="hljs-variable">%A2</span>/<span class="hljs-variable">#2</span>-Hexo-<span class="hljs-variable">%E6</span><span class="hljs-variable">%9</span>C<span class="hljs-variable">%AC</span><span class="hljs-variable">%E5</span><span class="hljs-variable">%9</span>C<span class="hljs-variable">%B0</span><span class="hljs-variable">%E5</span><span class="hljs-variable">%BB</span><span class="hljs-variable">%BA</span><span class="hljs-variable">%E7</span><span class="hljs-variable">%AB</span><span class="hljs-variable">%99</span><br></code></pre></td></tr></table></figure><h2 id="Hexo"><a href="#Hexo" class="headerlink" title="Hexo"></a>Hexo</h2><p>Hexo 是一款静态博客生成器。静态的意思是指生成的博客网站访客只能浏览，没法像淘宝那样在我们的网站上提交信息。Hexo 负责把我们写的 Markdown 文件根据选定的主题（规定网站的外观样式的文件）生成一堆 HTML 以及负责外观样式的 CSS 和 Javascript 文件。此外，Hexo 还提供了帮我们把这一堆 HTML、CSS、Javascript 文件上传到 Github 服务器的功能，也就是部署。<br>官方文档：<a href="https://hexo.io/zh-cn/docs/">https://hexo.io/zh-cn/docs/</a></p><h2 id="github-Page"><a href="#github-Page" class="headerlink" title="github Page"></a>github Page</h2><p>我们平时在新浪上看新闻的时候，所有的东西都要从新浪服务器发送到我们的手机、电脑上。我们的网站也一样，需要一个服务器，把用 Hexo 生成的那些 HTML、CSS、Javascript 文件发送给访客。但我们自己没有服务器呀？Github Pages 是 Github 提供的一项免费的静态页面托管服务，提供 your_name.github.io 的域名（your_name 为你的 Github 用户名）发布自己的静态网站。我们把 Hexo 生成的内容上传到 Github 服务器，访客的浏览器就是从 Github 服务器获取相关文件的。</p><h2 id="使用Hexo建立站点"><a href="#使用Hexo建立站点" class="headerlink" title="使用Hexo建立站点"></a>使用Hexo建立站点</h2><h3 id="安装Hexo"><a href="#安装Hexo" class="headerlink" title="安装Hexo"></a>安装Hexo</h3><p>切换node源为淘宝镜像</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">npm<span class="hljs-built_in"> config </span><span class="hljs-built_in">set</span> registry <span class="hljs-string">&quot;https://registry.npm.taobao.org&quot;</span><br></code></pre></td></tr></table></figure><p>使用nodejs来为我们安装</p><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs avrasm">npm install -g hexo-<span class="hljs-keyword">cli</span><br></code></pre></td></tr></table></figure><h3 id="建立站点"><a href="#建立站点" class="headerlink" title="建立站点"></a>建立站点</h3><ol><li><p>先在电脑中的某一位置建立好 <code>your_name.github.io</code> 文件夹，比如 <code>D:\Blog\your_name.github.io</code>；</p></li><li><p>在终端中切换到 <code>your_name.github.io</code> 文件夹所在的路径。需要注意的是，在 Windows 中，如果要进入某个磁盘，不需要敲 <code>cd</code>，直接敲盘符即可。比如我要进入 <code>D:\Blog\your_name.github.io</code>，那就输入 <code>D:</code> 回车，然后再 <code>cd Blog\your_name.github.io</code>；</p></li><li><p>根据 Hexo 的官方文档 <a href="https://hexo.io/zh-cn/docs/setup.html">开始使用 — 建站</a>，依次执行下面两条命令，建立我们的新网站：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cmake">hexo init<br>npm <span class="hljs-keyword">install</span><br></code></pre></td></tr></table></figure><p>换了淘宝的镜像后，应该能在几分钟内完成。完成后，<code>your_name.github.io</code> 文件夹下面的目录如下：</p><p><strong>其他没有的文件夹由于版本更新，尚未完全去了解，有需求的可自行去hexo官网了解。</strong></p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-bullet">.</span><br><span class="hljs-bullet"></span>├── <span class="hljs-emphasis">_config.yml</span><br><span class="hljs-emphasis">├── package.json</span><br><span class="hljs-emphasis">├── scaffolds</span><br><span class="hljs-emphasis">├── source</span><br><span class="hljs-emphasis">|   └── _</span>posts<br>└── themes<br></code></pre></td></tr></table></figure><ul><li><code>_config.yml</code> 文件存放着网站的配置信息，可以在这里配置大部分的参数。</li><li><code>package.json</code> 文件存放着插件信息，从中可以查看那些插件已经安装。</li><li><code>scaffolds</code> 是模板文件夹，新建文章时，Hexo 会根据 scaffold 来建立文件，不过这个模板和后面的主题里指的模板不一样。</li><li><code>source</code> 是存放用户资源的地方的文件夹，除 <code>_posts</code> 文件夹之外，开头命名为 <code>_</code> (下划线) 的文件 &#x2F; 文件夹和隐藏的文件将会被忽略。Markdown 和 HTML 文件会被解析并放到 <code>public</code> 文件夹（别急，等下会生成的），而其他文件会被拷贝过去。</li><li><code>themes</code> 主题文件夹，Hexo 会根据主题来生成静态页面，我们以后自己安装的主题也都会放在这个文件夹下面，默认的 landscape 主题已经在里面了。不同的主题可以根据自己的需要去网上下载，下载完成后放到主题文件夹，下载的主题一般来讲的话都是具有参考文档的会告诉你如何进行主题的切换</li></ul></li><li><p>根据 Hexo 的官方文档 <a href="https://hexo.io/zh-cn/docs/commands.html">开始使用 — 命令</a>，在终端中敲入 <code>hexo server</code> 命令（确保路径仍在 <code>your_name.github.io</code> 下），可以在 <a href="http://localhost:4000/">http://localhost:4000/</a> 中看到我们网站默认的样子了。</p></li><li><p>这个时候我们的本地网站其实已经建好了，但是并没有部署在我们的github page上，要在 Github 上创建项目，当然首先需要<a href="https://github.com/join?source=header-home">注册 Github帐号</a>。在注册完成后，Github 的官方文档 <a href="https://help.github.com/articles/create-a-repo/#create-a-new-repository-on-github">Create a new repository on GitHub</a> 已经图文并茂将如何建立一个 repository 交待得非常清楚明白了，唯一要注意的是，第二步里的 Repository name 一定要是 <code>your_name.github.io</code> ，<code>your_name</code> 是你的 Github 用户名。</p></li><li><p>因为<code>your_name.github.io</code>托管的是静态页面，所以我们首先必须将我们利用hexo建立好的网站生成静态文件，在我们建立的站点目录下直接cmd使用hexo generate 命令生成静态文件，执行完后我们的目录会多出一个public 文件夹里面就是生成的静态文件，也就是我们需要部署（上传）到github上的内容，</p><ol><li>hexo generate 到底做了啥我也很好奇，目前给我的感觉就是将我们站点下source文件夹里面的内容进行了解析在public 下生成了静态文件</li><li>Hexo 引入了差分机制，如果 <code>public</code> 目录存在，那么 <code>hexo g</code> 只会重新生成改动的文件。</li></ol></li></ol><h2 id="部署站点"><a href="#部署站点" class="headerlink" title="部署站点"></a>部署站点</h2><p>​部署站点有两种方式 一种是使用hexo 部署，另一种就是不使用hexo 进行部署</p><h3 id="使用Hexo进行部署"><a href="#使用Hexo进行部署" class="headerlink" title="使用Hexo进行部署"></a>使用Hexo进行部署</h3><p>Hexo 提供了 <code>hexo deploy</code> 命令，可以方便地将整个 <code>public</code> 文件夹部署到 Github 服务器上去。根据 Hexo 的官方文档 <a href="https://hexo.io/zh-cn/docs/deployment.html">基本操作 — 部署</a> 我们只需要做以下两步：</p><ul><li><p>在终端中运行如下命令，安装 <code>hexo-deployer-git</code> 插件：</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ada">npm install hexo-deployer-git <span class="hljs-comment">--save</span><br></code></pre></td></tr></table></figure></li><li><p>在 <code>_config.yml</code> 中修改参数，如下所示：</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs dts"><span class="hljs-symbol">deploy:</span><br><span class="hljs-symbol">  type:</span> git<br><span class="hljs-symbol">  repo:</span> https:<span class="hljs-comment">//github.com/your_name/your_name.github.io.git</span><br><span class="hljs-symbol">  branch:</span> master<br></code></pre></td></tr></table></figure><p>注意yml 文件冒号后的空格很重要</p></li><li><p>配置完成后直接使用<code>hexo deploy</code>命令将文件上传至Github仓库，在此之前确保静态文件已经生成，如果不想每次有了新内容后都进行一下<code>hexo g</code>,可以直接使用此命令参数<code>hexo deploy -g</code>部署之前预先生成静态文件</p></li></ul><h3 id="不使用Hexo部署"><a href="#不使用Hexo部署" class="headerlink" title="不使用Hexo部署"></a>不使用Hexo部署</h3><p>如果不使用一键部署的话那就需要手动建public下生成的静态文件上传至github仓库</p><ul><li>进入public文件夹，直接右键git bash here打开git，输入git init，将此文件夹作为仓库。</li><li>首先可以查看一下远程仓库的信息，如果没有的话 <code>git remote add origin 你的仓库地址</code>重新添加远程仓库</li><li>然后使用<code>git add .</code>将当前文件夹所有内容添加至暂存区，然后通过<code>git commit -m &#39;xxx&#39;</code>写个注释,最后通过<code>git push -u origin master</code>上传至远程仓库。 </li><li>在我们使用hexo new xxxx 生成了新博客内容后，我们需要<code>hexo g</code>重新生成静态文件，然后再重复上面操作，将新增内容上传至github仓库</li><li></li></ul><h2 id="有新内容再补充"><a href="#有新内容再补充" class="headerlink" title="有新内容再补充"></a>有新内容再补充</h2><p> 在使用<code>hexo deploy -g</code>命令部署后 第一次需要我们输入登录用户和密码，github从2021年8月13日起废除基于密码登录的身份验证模式而是采用个人访问令牌（Personal access tokens）的模式进行身份验证，所以我们在输入密码的时候需输入我们的个人访问令牌，<a href="https://blog.csdn.net/m0_56184347/article/details/124304029">https://blog.csdn.net/m0_56184347/article/details/124304029</a></p><h3 id="关于博客图片显示问题"><a href="#关于博客图片显示问题" class="headerlink" title="关于博客图片显示问题"></a>关于博客图片显示问题</h3><p>​当我们在typora中写好文档后，如果里面存在图片，直接使用<code>hexo deploy -g</code>部署到github时图片是无法显示的，可以选择将图片上传到github上 <a href="https://blog.csdn.net/Mr____Cheng/article/details/113723111">(123条消息) Hexo:在Typora中插图片的正确打开方式_typora root url_不一样的天蝎座的博客-CSDN博客</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>git常用命令及git本地仓库搭建</title>
    <link href="/2022/07/20/git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E5%8F%8Agit%E6%9C%AC%E5%9C%B0%E4%BB%93%E5%BA%93%E6%90%AD%E5%BB%BA/"/>
    <url>/2022/07/20/git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E5%8F%8Agit%E6%9C%AC%E5%9C%B0%E4%BB%93%E5%BA%93%E6%90%AD%E5%BB%BA/</url>
    
    <content type="html"><![CDATA[<h2 id="git常用命令及git本地仓库搭建"><a href="#git常用命令及git本地仓库搭建" class="headerlink" title="git常用命令及git本地仓库搭建"></a>git常用命令及git本地仓库搭建</h2><ul><li><p>本地仓库搭建</p><ol><li><p>首先需要在自己的电脑安装git</p></li><li><p>配置本地用户名</p><p>在git bash终端中输入</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs stylus">git config <span class="hljs-attr">--global</span> user<span class="hljs-selector-class">.name</span> <span class="hljs-string">&quot;YOUR NAME&quot;</span><br>git config <span class="hljs-attr">--global</span> user<span class="hljs-selector-class">.email</span> <span class="hljs-string">&quot;YOUR EMAIL ADDRESS&quot;</span><br></code></pre></td></tr></table></figure><p>其中，<code>YOUR NAME</code> 是自己取的名字，<code>YOUR EMAIL ADDRESS</code> 是自己的邮箱。由于自己的博客网站就自己一个人提交，所以就都设置成跟 Github 用户名和邮箱相同了。但其实是可以不同的，因为对于很多项目，并不只有一个开发者，Github 允许多人向同一个 Repo 提交，这里提供用户名和邮箱，只是为了搞清楚哪些代码是谁提交的。</p></li><li><p>一般本地仓库有两种产生途径</p><ol><li><p>在某个文件夹下面通过git init 命令初始化作为本地仓库</p><p>然后在通过git remote add origin  仓库地址 建立与远程仓库的连接</p></li><li><p>在某个文件夹下通过git clone 仓库地址  将远程仓库克隆下来作为自己的本地仓库</p><p>如果直接clone的是仓库地址，会将整个仓库都克隆下来，其中仓库名称作为文件名</p></li></ol></li></ol></li><li><p>git常用命令</p><ul><li>git init ：将当前目录初始化git仓库 作为本地仓库</li><li>git add  .  : 将当前目录下所有的的文件或者文件夹提交到暂存区</li><li>git commit -m “第一次提交”： 给暂存去待提交文件添加本次提交注释</li><li>git push -u origin master ：  向远程仓库田松文件<ol><li>需要注意的是一般都是在本地代码中第一次推送的时候 需要我们手动给他加上参数-u</li><li>后面再推送至远程仓库的时候就可以不需要用到我们的-u参数了</li></ol></li><li>git remote add origin  仓库地址：重新添加远程仓库地址建立链接</li><li>git pull –rebase origin master 获取远程库与本地同步合并(如果远程库不为空必须做这一步，否则后面的提交会失败)</li><li>git remote remove origin：删除远程仓库配置</li><li>git rm –cached “文件的位置或者路径” ：删除暂存区内容</li><li>git fetch : 从远程仓库下载新分支与数据</li><li>git pull ：从远端仓库提取数据并尝试合并到当前分支</li></ul><p>Git 参考手册：<a href="http://gitref.justjavac.com/">http://gitref.justjavac.com/</a></p><p>​</p></li></ul><p></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2022/07/19/hello-world/"/>
    <url>/2022/07/19/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
